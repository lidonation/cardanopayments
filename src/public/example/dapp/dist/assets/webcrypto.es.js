import{c as m}from"./__vite-browser-external.js";/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const Js="[object ArrayBuffer]";class p{static isArrayBuffer(e){return Object.prototype.toString.call(e)===Js}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e).slice().buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=p.toUint8Array(e),s=p.toUint8Array(t);if(r.length!==s.byteLength)return!1;for(let n=0;n<r.length;n++)if(r[n]!==s[n])return!1;return!0}static concat(...e){if(Array.isArray(e[0])){const t=e[0];let r=0;for(const o of t)r+=o.byteLength;const s=new Uint8Array(r);let n=0;for(const o of t){const a=this.toUint8Array(o);s.set(a,n),n+=a.length}return e[1]?this.toView(s,e[1]):s.buffer}else return this.concat(e)}}class tr{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return r.buffer}static toString(e){const t=p.toUint8Array(e);let r="";for(let n=0;n<t.length;n++)r+=String.fromCharCode(t[n]);return decodeURIComponent(escape(r))}}class ne{static toString(e,t=!1){const r=p.toArrayBuffer(e),s=new DataView(r);let n="";for(let o=0;o<r.byteLength;o+=2){const a=s.getUint16(o,t);n+=String.fromCharCode(a)}return n}static fromString(e,t=!1){const r=new ArrayBuffer(e.length*2),s=new DataView(r);for(let n=0;n<e.length;n++)s.setUint16(n*2,e.charCodeAt(n),t);return r}}class v{static isHex(e){return typeof e=="string"&&/^[a-z0-9]+$/i.test(e)}static isBase64(e){return typeof e=="string"&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}static isBase64Url(e){return typeof e=="string"&&/^[a-zA-Z0-9-_]+$/i.test(e)}static ToString(e,t="utf8"){const r=p.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return ne.toString(r,!0);case"utf16":case"utf16be":return ne.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return ne.fromString(e,!0);case"utf16":case"utf16be":return ne.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=p.toUint8Array(e);if(typeof btoa<"u"){const r=this.ToString(t,"binary");return btoa(r)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!v.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!v.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=v.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return tr.fromString(e);case"utf16":case"utf16be":return ne.fromString(e);case"utf16le":case"usc2":return ne.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=v.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return tr.toString(e);case"utf16":case"utf16be":return ne.toString(e);case"utf16le":case"usc2":return ne.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const t=p.toUint8Array(e);let r="";for(let s=0;s<t.length;s++)r+=String.fromCharCode(t[s]);return r}static ToHex(e){const t=p.toUint8Array(e),r="",s=[],n=t.length;for(let o=0;o<n;o++){const a=t[o].toString(16).padStart(2,"0");s.push(a)}return s.join(r)}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!v.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let s=0;s<t.length;s=s+2){const n=t.slice(s,s+2);r[s/2]=parseInt(n,16)}return r.buffer}static ToUtf16String(e,t=!1){return ne.toString(e,t)}static FromUtf16String(e,t=!1){return ne.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}}v.DEFAULT_UTF8_ENCODING="utf8";function dr(...i){const e=i.map(s=>s.byteLength).reduce((s,n)=>s+n),t=new Uint8Array(e);let r=0;return i.map(s=>new Uint8Array(s)).forEach(s=>{for(const n of s)t[r++]=n}),t.buffer}/*!
 Copyright (c) Peculiar Ventures, LLC
*/function Ce(i,e){let t=0;if(i.length===1)return i[0];for(let r=i.length-1;r>=0;r--)t+=i[i.length-1-r]*Math.pow(2,e*r);return t}function be(i,e,t=-1){const r=t;let s=i,n=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(i<o){let c;if(r<0)c=new ArrayBuffer(a),n=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),n=r}const l=new Uint8Array(c);for(let h=a-1;h>=0;h--){const u=Math.pow(2,h*e);l[n-h-1]=Math.floor(s/u),s-=l[n-h-1]*u}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Nt(...i){let e=0,t=0;for(const n of i)e+=n.length;const r=new ArrayBuffer(e),s=new Uint8Array(r);for(const n of i)s.set(n,t),t+=n.length;return s}function pr(){const i=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=i[0]===255&&i[1]&128,c=i[0]===0&&(i[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=i[0]&128;const r=Ce(t,8),s=new ArrayBuffer(this.valueHex.byteLength),n=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)n[a]=i[a];return n[0]&=127,Ce(n,8)-r}function Fs(i){const e=i<0?i*-1:i;let t=128;for(let r=1;r<8;r++){if(e<=t){if(i<0){const o=t-e,a=be(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let s=be(e,8,r),n=new Uint8Array(s);if(n[0]&128){const o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),n=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)n[c+1]=a[c];n[0]=0}return s}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function zs(i,e){if(i.byteLength!==e.byteLength)return!1;const t=new Uint8Array(i),r=new Uint8Array(e);for(let s=0;s<t.length;s++)if(t[s]!==r[s])return!1;return!0}function F(i,e){const t=i.toString(10);if(e<t.length)return"";const r=e-t.length,s=new Array(r);for(let o=0;o<r;o++)s[o]="0";return s.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function Ye(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Vt(i){let e=0,t=0;for(let s=0;s<i.length;s++){const n=i[s];e+=n.byteLength}const r=new Uint8Array(e);for(let s=0;s<i.length;s++){const n=i[s];r.set(new Uint8Array(n),t),t+=n.byteLength}return r.buffer}function ye(i,e,t,r){return e instanceof Uint8Array?e.byteLength?t<0?(i.error="Wrong parameter: inputOffset less than zero",!1):r<0?(i.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-r<0?(i.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(i.error="Wrong parameter: inputBuffer has zero length",!1):(i.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class nt{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return Vt(this.items)}}const Le=[new Uint8Array([1])],rr="0123456789",Kt="name",sr="valueHexView",js="isHexOnly",Gs="idBlock",qs="tagClass",Ws="tagNumber",Ys="isConstructed",Xs="fromBER",Zs="toBER",Qs="local",M="",ee=new ArrayBuffer(0),it=new Uint8Array(0),$e="EndOfContent",gr="OCTET STRING",mr="BIT STRING";function ae(i){var e;return e=class extends i{constructor(...r){var s;super(...r);const n=r[0]||{};this.isHexOnly=(s=n.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=n.valueHex?p.toUint8Array(n.valueHex):it}get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}fromBER(r,s,n){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!ye(this,o,s,n))return-1;const a=s+n;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=n,a):(this.warnings.push("Zero buffer length"),s)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",ee)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:v.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class Se{constructor({blockLength:e=0,error:t=M,warnings:r=[],valueBeforeDecode:s=it}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=p.toUint8Array(s)}static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:v.ToHex(this.valueBeforeDecodeView)}}}Se.NAME="baseBlock";class T extends Se{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}T.NAME="valueBlock";class wr extends ae(Se){constructor({idBlock:e={}}={}){var t,r,s,n;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?p.toUint8Array(e.valueHex):it,this.tagClass=(r=e.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(s=e.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(n=e.isConstructed)!==null&&n!==void 0?n:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",ee}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const s=new Uint8Array(1);if(!e){let n=this.tagNumber;n&=31,t|=n,s[0]=t}return s.buffer}if(!this.isHexOnly){const s=be(this.tagNumber,7),n=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=n[c]|128;a[o]=n[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=t|31,!e){const s=this.valueHexView;for(let n=0;n<s.length-1;n++)r[n+1]=s[n]|128;r[this.valueHexView.byteLength]=s[s.length-1]}return r.buffer}fromBER(e,t,r){const s=p.toUint8Array(e);if(!ye(this,s,t,r))return-1;const n=s.subarray(t,t+r);if(n.length===0)return this.error="Zero buffer length",-1;switch(n[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(n[0]&32)===32,this.isHexOnly=!1;const a=n[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),h=255;for(;n[c]&128;){if(l[c-1]=n[c]&127,c++,c>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(c===h){h+=255;const w=new Uint8Array(h);for(let B=0;B<l.length;B++)w[B]=l[B];l=this.valueHexView=new Uint8Array(h)}}this.blockLength=c+1,l[c-1]=n[c]&127;const u=new Uint8Array(c);for(let w=0;w<c;w++)u[w]=l[w];l=this.valueHexView=new Uint8Array(c),l.set(u),this.blockLength<=9?this.tagNumber=Ce(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}wr.NAME="identificationBlock";class vr extends Se{constructor({lenBlock:e={}}={}){var t,r,s;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(r=e.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(s=e.length)!==null&&s!==void 0?s:0}fromBER(e,t,r){const s=p.toUint8Array(e);if(!ye(this,s,t,r))return-1;const n=s.subarray(t,t+r);if(n.length===0)return this.error="Zero buffer length",-1;if(n[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=n[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(n[0]&128),this.longFormUsed===!1)return this.length=n[0],this.blockLength=1,t+this.blockLength;const o=n[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Ce(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const s=be(this.length,8);if(s.byteLength>127)return this.error="Too big length",ee;if(t=new ArrayBuffer(s.byteLength+1),e)return t;const n=new Uint8Array(s);r=new Uint8Array(t),r[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)r[o+1]=n[o];return t}return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}vr.NAME="lengthBlock";const y={};class O extends Se{constructor({name:e=M,optional:t=!1,primitiveSchema:r,...s}={},n){super(s),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new wr(s),this.lenBlock=new vr(s),this.valueBlock=n?new n(s):new T(s)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){const r=t||new nt;t||Ar(this);const s=this.idBlock.toBER(e);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const n=this.valueBlock.toBER(e);this.lenBlock.length=n.byteLength;const o=this.lenBlock.toBER(e);r.write(o),r.write(n)}return t?ee:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():v.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${v.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),r=e.toBER();return zs(t,r)}}O.NAME="BaseBlock";function Ar(i){if(i instanceof y.Constructed)for(const e of i.valueBlock.value)Ar(e)&&(i.lenBlock.isIndefiniteForm=!0);return!!i.lenBlock.isIndefiniteForm}class Ht extends O{constructor({value:e=M,...t}={},r){super(t,r),e&&this.fromString(e)}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Ht.NAME="BaseStringBlock";class br extends ae(T){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}br.NAME="PrimitiveValueBlock";var kr;class Je extends O{constructor(e={}){super(e,br),this.idBlock.isConstructed=!1}}kr=Je;y.Primitive=kr;Je.NAME="PRIMITIVE";function en(i,e){if(i instanceof e)return i;const t=new e;return t.idBlock=i.idBlock,t.lenBlock=i.lenBlock,t.warnings=i.warnings,t.valueBeforeDecodeView=i.valueBeforeDecodeView,t}function Pe(i,e=0,t=i.length){const r=e;let s=new O({},T);const n=new Se;if(!ye(n,i,e,t))return s.error=n.error,{offset:-1,result:s};if(!i.subarray(e,e+t).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(i,e,t);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(e=a,t-=s.idBlock.blockLength,a=s.lenBlock.fromBER(i,e,t),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=a,t-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=O;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=y.EndOfContent;break;case 1:c=y.Boolean;break;case 2:c=y.Integer;break;case 3:c=y.BitString;break;case 4:c=y.OctetString;break;case 5:c=y.Null;break;case 6:c=y.ObjectIdentifier;break;case 10:c=y.Enumerated;break;case 12:c=y.Utf8String;break;case 13:c=y.RelativeObjectIdentifier;break;case 14:c=y.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=y.Sequence;break;case 17:c=y.Set;break;case 18:c=y.NumericString;break;case 19:c=y.PrintableString;break;case 20:c=y.TeletexString;break;case 21:c=y.VideotexString;break;case 22:c=y.IA5String;break;case 23:c=y.UTCTime;break;case 24:c=y.GeneralizedTime;break;case 25:c=y.GraphicString;break;case 26:c=y.VisibleString;break;case 27:c=y.GeneralString;break;case 28:c=y.UniversalString;break;case 29:c=y.CharacterString;break;case 30:c=y.BmpString;break;case 31:c=y.DATE;break;case 32:c=y.TimeOfDay;break;case 33:c=y.DateTime;break;case 34:c=y.Duration;break;default:{const l=s.idBlock.isConstructed?new y.Constructed:new y.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?y.Constructed:y.Primitive}return s=en(s,c),a=s.fromBER(i,e,s.lenBlock.isIndefiniteForm?t:s.lenBlock.length),s.valueBeforeDecodeView=i.subarray(r,r+s.blockLength),{offset:a,result:s}}function Ke(i){if(!i.byteLength){const e=new O({},T);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Pe(p.toUint8Array(i).slice(),0,i.byteLength)}function tn(i,e){return i?1:e}class ge extends T{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const s=p.toUint8Array(e);if(!ye(this,s,t,r))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let n=t;for(;tn(this.isIndefiniteForm,r)>0;){const o=Pe(s,n,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(n=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===$e)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===$e?this.value.pop():this.warnings.push("No EndOfContent block encoded")),n}toBER(e,t){const r=t||new nt;for(let s=0;s<this.value.length;s++)this.value[s].toBER(e,r);return t?ee:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}ge.NAME="ConstructedValueBlock";var Br;class _ extends O{constructor(e={}){super(e,ge),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const e=[];for(const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map(s=>`  ${s}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}Br=_;y.Constructed=Br;_.NAME="CONSTRUCTED";class Sr extends T{fromBER(e,t,r){return t}toBER(e){return ee}}Sr.override="EndOfContentValueBlock";var Er;class Ot extends O{constructor(e={}){super(e,Sr),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}Er=Ot;y.EndOfContent=Er;Ot.NAME=$e;var xr;class ke extends O{constructor(e={}){super(e,T),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const s=new Uint8Array(r);s[0]=5,s[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}xr=ke;y.Null=xr;ke.NAME="NULL";class Kr extends ae(T){constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=p.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}fromBER(e,t,r){const s=p.toUint8Array(e);return ye(this,s,t,r)?(this.valueHexView=s.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,pr.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}Kr.NAME="BooleanValueBlock";var Cr;class ot extends O{constructor(e={}){super(e,Kr),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}Cr=ot;y.Boolean=Cr;ot.NAME="BOOLEAN";class Nr extends ae(ge){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=ge.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(let n=0;n<this.value.length;n++){const o=this.value[n].constructor.NAME;if(o===$e){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==gr)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e,t){return this.isConstructed?ge.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}Nr.NAME="OctetStringValueBlock";var Ur;class Ve extends O{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,n;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((n=r.value)===null||n===void 0)&&n.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Nr),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const n=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(n.byteLength){const o=Pe(n,0,n.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?_.prototype.onAsciiEncoding.call(this):`${this.constructor.NAME} : ${v.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof Ve&&e.push(t.valueBlock.valueHexView);return p.concat(e)}}Ur=Ve;y.OctetString=Ur;Ve.NAME=gr;class Ir extends ae(ge){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let s=-1;if(this.isConstructed){if(s=ge.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(const a of this.value){const c=a.constructor.NAME;if(c===$e){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==mr)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return s}const n=p.toUint8Array(e);if(!ye(this,n,t,r))return-1;const o=n.subarray(t,t+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=Pe(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+r}toBER(e,t){if(this.isConstructed)return ge.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return ee;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}Ir.NAME="BitStringValueBlock";var Pr;class at extends O{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,n;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((n=r.value)===null||n===void 0)&&n.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Ir),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return _.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const s of t)e.push(s.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}Pr=at;y.BitString=Pr;at.NAME=mr;var Vr;function rn(i,e){const t=new Uint8Array([0]),r=new Uint8Array(i),s=new Uint8Array(e);let n=r.slice(0);const o=n.length-1,a=s.slice(0),c=a.length-1;let l=0;const h=c<o?o:c;let u=0;for(let w=h;w>=0;w--,u++){switch(!0){case u<a.length:l=n[o-u]+a[c-u]+t[0];break;default:l=n[o-u]+t[0]}switch(t[0]=l/10,!0){case u>=n.length:n=Nt(new Uint8Array([l%10]),n);break;default:n[o-u]=l%10}}return t[0]>0&&(n=Nt(t,n)),n}function nr(i){if(i>=Le.length)for(let e=Le.length;e<=i;e++){const t=new Uint8Array([0]);let r=Le[e-1].slice(0);for(let s=r.length-1;s>=0;s--){const n=new Uint8Array([(r[s]<<1)+t[0]]);t[0]=n[0]/10,r[s]=n[0]%10}t[0]>0&&(r=Nt(t,r)),Le.push(r)}return Le[i]}function sn(i,e){let t=0;const r=new Uint8Array(i),s=new Uint8Array(e),n=r.slice(0),o=n.length-1,a=s.slice(0),c=a.length-1;let l,h=0;for(let u=c;u>=0;u--,h++)switch(l=n[o-h]-a[c-h]-t,!0){case l<0:t=1,n[o-h]=l+10;break;default:t=0,n[o-h]=l}if(t>0)for(let u=o-c+1;u>=0;u--,h++)if(l=n[o-h]-t,l<0)t=1,n[o-h]=l+10;else{t=0,n[o-h]=l;break}return n.slice()}class Rt extends ae(T){constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=pr.call(this)))}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(Fs(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const n=this.fromBER(e,t,r);if(n===-1)return n;const o=this.valueHexView;return o[0]===0&&(o[1]&128)!==0?this.valueHexView=o.subarray(1):s!==0&&o.length<s&&(s-o.length>1&&(s=o.length+1),this.valueHexView=o.subarray(s-o.length)),n}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(t,1),this.valueHexView=r}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return s===-1||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),r=0,s;const n=this.valueHexView;let o="",a=!1;for(let c=n.byteLength-1;c>=0;c--){s=n[c];for(let l=0;l<8;l++){if((s&1)===1)switch(r){case e:t=sn(nr(r),t),o="-";break;default:t=rn(t,nr(r))}r++,s>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=rr.charAt(t[c]));return a===!1&&(o+=rr.charAt(0)),o}}Vr=Rt;Rt.NAME="IntegerValueBlock";Object.defineProperty(Vr.prototype,"valueHex",{set:function(i){this.valueHexView=new Uint8Array(i),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var Hr;class q extends O{constructor(e={}){super(e,Rt),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return Ye(),BigInt(this.valueBlock.toString())}static fromBigInt(e){Ye();const t=BigInt(e),r=new nt,s=t.toString(16).replace(/^-/,""),n=new Uint8Array(v.FromHex(s));if(t<0){const a=new Uint8Array(n.length+(n[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${v.ToHex(a)}`)+t,h=p.toUint8Array(v.FromHex(l.toString(16)));h[0]|=128,r.write(h)}else n[0]&128&&r.write(new Uint8Array([0])),r.write(n);return new q({valueHex:r.final()})}convertToDER(){const e=new q({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new q({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}Hr=q;y.Integer=Hr;q.NAME="INTEGER";var Or;class ct extends q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}Or=ct;y.Enumerated=Or;ct.NAME="ENUMERATED";class Ut extends ae(T){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const s=p.toUint8Array(e);if(!ye(this,s,t,r))return-1;const n=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=n[a]&127,this.blockLength++,(n[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(n[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Ce(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){Ye();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let s=0;s<r.length;s++)r[s]=parseInt(t.slice(s*7,s*7+7),2)+(s+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,n=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)n[o]=s[o]|128;return n[this.blockLength-1]=s[this.blockLength-1],n.buffer}const t=be(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ee;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),n=t.byteLength-1;for(let o=0;o<n;o++)r[o]=s[o]|128;r[n]=s[n]}return r}toString(){let e="";if(this.isHexOnly)e=v.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Ut.NAME="sidBlock";class Rr extends T{constructor({value:e=M,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const n=new Ut;if(s=n.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=n.error,s;this.value.length===0&&(n.isFirstSid=!0),this.blockLength+=n.blockLength,r-=n.blockLength,this.value.push(n)}return s}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(s.byteLength===0)return this.error=this.value[r].error,ee;t.push(s)}return Vt(t)}fromString(e){this.value=[];let t=0,r=0,s="",n=!1;do if(r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1,n){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(s,10);if(isNaN(c))return;o.valueDec=c+a,n=!1}else{const o=new Ut;if(s>Number.MAX_SAFE_INTEGER){Ye();const a=BigInt(s);o.valueBigInt=a}else if(o.valueDec=parseInt(s,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,n=!0),this.value.push(o)}while(r!==-1)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Rr.NAME="ObjectIdentifierValueBlock";var Lr;class lt extends O{constructor(e={}){super(e,Rr),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Lr=lt;y.ObjectIdentifier=Lr;lt.NAME="OBJECT IDENTIFIER";class It extends ae(Se){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(r===0)return t;const s=p.toUint8Array(e);if(!ye(this,s,t,r))return-1;const n=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=n[a]&127,this.blockLength++,(n[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(n[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Ce(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,n=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)n[o]=s[o]|128;return n[this.blockLength-1]=s[this.blockLength-1],n.buffer}const t=be(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",ee;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),n=t.byteLength-1;for(let o=0;o<n;o++)r[o]=s[o]|128;r[n]=s[n]}return r.buffer}toString(){let e="";return this.isHexOnly?e=v.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}It.NAME="relativeSidBlock";class Dr extends T{constructor({value:e=M,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const n=new It;if(s=n.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=n.error,s;this.blockLength+=n.blockLength,r-=n.blockLength,this.value.push(n)}return s}toBER(e,t){const r=[];for(let s=0;s<this.value.length;s++){const n=this.value[s].toBER(e);if(n.byteLength===0)return this.error=this.value[s].error,ee;r.push(n)}return Vt(r)}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1;const n=new It;if(n.valueDec=parseInt(s,10),isNaN(n.valueDec))return!0;this.value.push(n)}while(r!==-1);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t&&(s=`{${s}}`),e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Dr.NAME="RelativeObjectIdentifierValueBlock";var Tr;class Lt extends O{constructor(e={}){super(e,Dr),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Tr=Lt;y.RelativeObjectIdentifier=Tr;Lt.NAME="RelativeObjectIdentifier";var $r;class he extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}$r=he;y.Sequence=$r;he.NAME="SEQUENCE";var Mr;class fe extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}Mr=fe;y.Set=Mr;fe.NAME="SET";class _r extends ae(T){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=M}toJSON(){return{...super.toJSON(),value:this.value}}}_r.NAME="StringValueBlock";class Jr extends _r{}Jr.NAME="SimpleStringValueBlock";class z extends Ht{constructor({...e}={}){super(e,Jr)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,p.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}z.NAME="SIMPLE STRING";class Fr extends z{fromBuffer(e){this.valueBlock.valueHexView=p.toUint8Array(e);try{this.valueBlock.value=v.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=v.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(v.FromUtf8String(e)),this.valueBlock.value=e}}Fr.NAME="Utf8StringValueBlock";var zr;class de extends Fr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}zr=de;y.Utf8String=zr;de.NAME="UTF8String";class jr extends z{fromBuffer(e){this.valueBlock.value=v.ToUtf16String(e),this.valueBlock.valueHexView=p.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(v.FromUtf16String(e))}}jr.NAME="BmpStringValueBlock";var Gr;class ut extends jr{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}Gr=ut;y.BmpString=Gr;ut.NAME="BMPString";class qr extends z{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let s=0;s<r.length;s+=4)r[s]=r[s+3],r[s+1]=r[s+2],r[s+2]=0,r[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let s=0;s<t;s++){const n=be(e.charCodeAt(s),8),o=new Uint8Array(n);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[s*4+c+a]=o[c]}this.valueBlock.value=e}}qr.NAME="UniversalStringValueBlock";var Wr;class ht extends qr{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}Wr=ht;y.UniversalString=Wr;ht.NAME="UniversalString";var Yr;class ft extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}Yr=ft;y.NumericString=Yr;ft.NAME="NumericString";var Xr;class yt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Xr=yt;y.PrintableString=Xr;yt.NAME="PrintableString";var Zr;class dt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}Zr=dt;y.TeletexString=Zr;dt.NAME="TeletexString";var Qr;class pt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}Qr=pt;y.VideotexString=Qr;pt.NAME="VideotexString";var es;class gt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}es=gt;y.IA5String=es;gt.NAME="IA5String";var ts;class mt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}ts=mt;y.GraphicString=ts;mt.NAME="GraphicString";var rs;class Fe extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}rs=Fe;y.VisibleString=rs;Fe.NAME="VisibleString";var ss;class wt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}ss=wt;y.GeneralString=ss;wt.NAME="GeneralString";var ns;class vt extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}ns=vt;y.CharacterString=ns;vt.NAME="CharacterString";var is;class ze extends Fe{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let s=0;s<e.length;s++)this.valueBlock.valueHexView[s]=e.charCodeAt(s)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,p.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(r===null){this.error="Wrong input string for conversion";return}const s=parseInt(r[1],10);s>=50?this.year=1900+s:this.year=2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=F(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=F(this.month,2),t[2]=F(this.day,2),t[3]=F(this.hour,2),t[4]=F(this.minute,2),t[5]=F(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}is=ze;y.UTCTime=is;ze.NAME="UTCTime";var os;class At extends ze{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t=!1,r="",s="",n=0,o,a=0,c=0;if(e[e.length-1]==="Z")r=e.substring(0,e.length-1),t=!0;else{const u=new Number(e[e.length-1]);if(isNaN(u.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(t){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let u=1,w=r.indexOf("+"),B="";if(w===-1&&(w=r.indexOf("-"),u=-1),w!==-1){if(B=r.substring(w+1),r=r.substring(0,w),B.length!==2&&B.length!==4)throw new Error("Wrong input string for conversion");let C=parseInt(B.substring(0,2),10);if(isNaN(C.valueOf()))throw new Error("Wrong input string for conversion");if(a=u*C,B.length===4){if(C=parseInt(B.substring(2,4),10),isNaN(C.valueOf()))throw new Error("Wrong input string for conversion");c=u*C}}}let l=r.indexOf(".");if(l===-1&&(l=r.indexOf(",")),l!==-1){const u=new Number(`0${r.substring(l)}`);if(isNaN(u.valueOf()))throw new Error("Wrong input string for conversion");n=u.valueOf(),s=r.substring(0,l)}else s=r;switch(!0){case s.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case s.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let u=60*n;this.minute=Math.floor(u),u=60*(u-this.minute),this.second=Math.floor(u),u=1e3*(u-this.second),this.millisecond=Math.floor(u)}break;case s.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let u=60*n;this.second=Math.floor(u),u=1e3*(u-this.second),this.millisecond=Math.floor(u)}break;case s.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const u=1e3*n;this.millisecond=Math.floor(u)}break;default:throw new Error("Wrong input string for conversion")}const h=o.exec(s);if(h===null)throw new Error("Wrong input string for conversion");for(let u=1;u<h.length;u++)switch(u){case 1:this.year=parseInt(h[u],10);break;case 2:this.month=parseInt(h[u],10);break;case 3:this.day=parseInt(h[u],10);break;case 4:this.hour=parseInt(h[u],10)+a;break;case 5:this.minute=parseInt(h[u],10)+c;break;case 6:this.second=parseInt(h[u],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const u=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=u.getUTCFullYear(),this.month=u.getUTCMonth(),this.day=u.getUTCDay(),this.hour=u.getUTCHours(),this.minute=u.getUTCMinutes(),this.second=u.getUTCSeconds(),this.millisecond=u.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(F(this.year,4)),t.push(F(this.month,2)),t.push(F(this.day,2)),t.push(F(this.hour,2)),t.push(F(this.minute,2)),t.push(F(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(F(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}os=At;y.GeneralizedTime=os;At.NAME="GeneralizedTime";var as;class Dt extends de{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}as=Dt;y.DATE=as;Dt.NAME="DATE";var cs;class Tt extends de{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}cs=Tt;y.TimeOfDay=cs;Tt.NAME="TimeOfDay";var ls;class $t extends de{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}ls=$t;y.DateTime=ls;$t.NAME="DateTime";var us;class Mt extends de{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}us=Mt;y.Duration=us;Mt.NAME="Duration";var hs;class _t extends de{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}hs=_t;y.TIME=hs;_t.NAME="TIME";class Be{constructor({name:e=M,optional:t=!1}={}){this.name=e,this.optional=t}}class Jt extends Be{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Xe extends Be{constructor({value:e=new Be,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}class nn{constructor({data:e=it}={}){this.dataView=p.toUint8Array(e)}get data(){return this.dataView.slice().buffer}set data(e){this.dataView=p.toUint8Array(e)}fromBER(e,t,r){const s=t+r;return this.dataView=p.toUint8Array(e).subarray(t,s),s}toBER(e){return this.dataView.slice().buffer}}function we(i,e,t){if(t instanceof Jt){for(let n=0;n<t.value.length;n++)if(we(i,e,t.value[n]).verified)return{verified:!0,result:i};{const n={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(Kt)&&(n.name=t.name),n}}if(t instanceof Be)return t.hasOwnProperty(Kt)&&(i[t.name]=e),{verified:!0,result:i};if(!(i instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Gs in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Xs in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(Zs in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const r=t.idBlock.toBER(!1);if(r.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(r,0,r.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(qs)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:i};if(t.idBlock.hasOwnProperty(Ws)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:i};if(t.idBlock.hasOwnProperty(Ys)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:i};if(!(js in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:i};if(t.idBlock.isHexOnly){if(!(sr in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(n.length!==o.length)return{verified:!1,result:i};for(let a=0;a<n.length;a++)if(n[a]!==o[1])return{verified:!1,result:i}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&(i[t.name]=e)),t instanceof y.Constructed){let n=0,o={verified:!1,result:{error:"Unknown error"}},a=t.valueBlock.value.length;if(a>0&&t.valueBlock.value[0]instanceof Xe&&(a=e.valueBlock.value.length),a===0)return{verified:!0,result:i};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let c=!0;for(let l=0;l<t.valueBlock.value.length;l++)c=c&&(t.valueBlock.value[l].optional||!1);return c?{verified:!0,result:i}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&delete i[t.name]),i.error="Inconsistent object length",{verified:!1,result:i})}for(let c=0;c<a;c++)if(c-n>=e.valueBlock.value.length){if(t.valueBlock.value[c].optional===!1){const l={verified:!1,result:i};return i.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&(delete i[t.name],l.name=t.name)),l}}else if(t.valueBlock.value[0]instanceof Xe){if(o=we(i,e.valueBlock.value[c],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)n++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&delete i[t.name]),o;if(Kt in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let l={};Qs in t.valueBlock.value[0]&&t.valueBlock.value[0].local?l=e:l=i,typeof l[t.valueBlock.value[0].name]>"u"&&(l[t.valueBlock.value[0].name]=[]),l[t.valueBlock.value[0].name].push(e.valueBlock.value[c])}}else if(o=we(i,e.valueBlock.value[c-n],t.valueBlock.value[c]),o.verified===!1)if(t.valueBlock.value[c].optional)n++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&delete i[t.name]),o;if(o.verified===!1){const c={verified:!1,result:i};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&(delete i[t.name],c.name=t.name)),c}return{verified:!0,result:i}}if(t.primitiveSchema&&sr in e.valueBlock){const n=Pe(e.valueBlock.valueHexView);if(n.offset===-1){const o={verified:!1,result:n.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,M),t.name&&(delete i[t.name],o.name=t.name)),o}return we(i,n.result,t.primitiveSchema)}return{verified:!0,result:i}}function on(i,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const t=Pe(p.toUint8Array(i));return t.offset===-1?{verified:!1,result:t.result}:we(t.result,t.result,e)}const fs=Object.freeze(Object.defineProperty({__proto__:null,Any:Be,BaseBlock:O,BaseStringBlock:Ht,BitString:at,BmpString:ut,Boolean:ot,CharacterString:vt,Choice:Jt,Constructed:_,DATE:Dt,DateTime:$t,Duration:Mt,EndOfContent:Ot,Enumerated:ct,GeneralString:wt,GeneralizedTime:At,GraphicString:mt,HexBlock:ae,IA5String:gt,Integer:q,Null:ke,NumericString:ft,ObjectIdentifier:lt,OctetString:Ve,Primitive:Je,PrintableString:yt,RawData:nn,RelativeObjectIdentifier:Lt,Repeated:Xe,Sequence:he,Set:fe,TIME:_t,TeletexString:dt,TimeOfDay:Tt,UTCTime:ze,UniversalString:ht,Utf8String:de,ValueBlock:T,VideotexString:pt,ViewWriter:nt,VisibleString:Fe,compareSchema:we,fromBER:Ke,verifySchema:on},Symbol.toStringTag,{value:"Module"}));var R;(function(i){i[i.Sequence=0]="Sequence",i[i.Set=1]="Set",i[i.Choice=2]="Choice"})(R||(R={}));var g;(function(i){i[i.Any=1]="Any",i[i.Boolean=2]="Boolean",i[i.OctetString=3]="OctetString",i[i.BitString=4]="BitString",i[i.Integer=5]="Integer",i[i.Enumerated=6]="Enumerated",i[i.ObjectIdentifier=7]="ObjectIdentifier",i[i.Utf8String=8]="Utf8String",i[i.BmpString=9]="BmpString",i[i.UniversalString=10]="UniversalString",i[i.NumericString=11]="NumericString",i[i.PrintableString=12]="PrintableString",i[i.TeletexString=13]="TeletexString",i[i.VideotexString=14]="VideotexString",i[i.IA5String=15]="IA5String",i[i.GraphicString=16]="GraphicString",i[i.VisibleString=17]="VisibleString",i[i.GeneralString=18]="GeneralString",i[i.CharacterString=19]="CharacterString",i[i.UTCTime=20]="UTCTime",i[i.GeneralizedTime=21]="GeneralizedTime",i[i.DATE=22]="DATE",i[i.TimeOfDay=23]="TimeOfDay",i[i.DateTime=24]="DateTime",i[i.Duration=25]="Duration",i[i.TIME=26]="TIME",i[i.Null=27]="Null"})(g||(g={}));const an={fromASN:i=>i instanceof ke?null:i.valueBeforeDecodeView,toASN:i=>{if(i===null)return new ke;const e=Ke(i);if(e.result.error)throw new Error(e.result.error);return e.result}},Ft={fromASN:i=>i.valueBlock.valueHexView.byteLength>=4?i.valueBlock.toString():i.valueBlock.valueDec,toASN:i=>new q({value:+i})},cn={fromASN:i=>i.valueBlock.valueDec,toASN:i=>new ct({value:i})},ln={fromASN:i=>i.valueBlock.valueHexView,toASN:i=>new at({valueHex:i})},un={fromASN:i=>i.valueBlock.toString(),toASN:i=>new lt({value:i})},hn={fromASN:i=>i.valueBlock.value,toASN:i=>new ot({value:i})},fn={fromASN:i=>i.valueBlock.valueHexView,toASN:i=>new Ve({valueHex:i})};function W(i){return{fromASN:e=>e.valueBlock.value,toASN:e=>new i({value:e})}}const yn=W(de),dn=W(ut),pn=W(ht),gn=W(ft),mn=W(yt),wn=W(dt),vn=W(pt),An=W(gt),bn=W(mt),kn=W(Fe),Bn=W(wt),Sn=W(vt),En={fromASN:i=>i.toDate(),toASN:i=>new ze({valueDate:i})},xn={fromASN:i=>i.toDate(),toASN:i=>new At({valueDate:i})},Kn={fromASN:()=>null,toASN:()=>new ke};function zt(i){switch(i){case g.Any:return an;case g.BitString:return ln;case g.BmpString:return dn;case g.Boolean:return hn;case g.CharacterString:return Sn;case g.Enumerated:return cn;case g.GeneralString:return Bn;case g.GeneralizedTime:return xn;case g.GraphicString:return bn;case g.IA5String:return An;case g.Integer:return Ft;case g.Null:return Kn;case g.NumericString:return gn;case g.ObjectIdentifier:return un;case g.OctetString:return fn;case g.PrintableString:return mn;case g.TeletexString:return wn;case g.UTCTime:return En;case g.UniversalString:return pn;case g.Utf8String:return yn;case g.VideotexString:return vn;case g.VisibleString:return kn;default:return null}}function ue(i){return typeof i=="function"&&i.prototype?i.prototype.toASN&&i.prototype.fromASN?!0:ue(i.prototype):!!(i&&typeof i=="object"&&"toASN"in i&&"fromASN"in i)}function ys(i){var e;if(i){const t=Object.getPrototypeOf(i);return((e=t?.prototype)===null||e===void 0?void 0:e.constructor)===Array?!0:ys(t)}return!1}function Cn(i,e){if(!(i&&e)||i.byteLength!==e.byteLength)return!1;const t=new Uint8Array(i),r=new Uint8Array(e);for(let s=0;s<i.byteLength;s++)if(t[s]!==r[s])return!1;return!0}class Nn{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const r=this.items.get(e);if(!r)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!r.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return r}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:R.Sequence,items:{}},r=this.findParentSchema(e);return r&&(Object.assign(t,r),t.items=Object.assign({},t.items,r.items)),t}create(e,t){const r=this.items.get(e)||this.createDefault(e),s=[];for(const n in r.items){const o=r.items[n],a=t?n:"";let c;if(typeof o.type=="number"){const h=g[o.type],u=fs[h];if(!u)throw new Error(`Cannot get ASN1 class by name '${h}'`);c=new u({name:a})}else ue(o.type)?c=new o.type().toSchema(a):o.optional?this.get(o.type).type===R.Choice?c=new Be({name:a}):(c=this.create(o.type,!1),c.name=a):c=new Be({name:a});const l=!!o.optional||o.defaultValue!==void 0;if(o.repeated){c.name="";const h=o.repeated==="set"?fe:he;c=new h({name:"",value:[new Xe({name:a,value:c})]})}if(o.context!==null&&o.context!==void 0)if(o.implicit)if(typeof o.type=="number"||ue(o.type)){const h=o.repeated?_:Je;s.push(new h({name:a,optional:l,idBlock:{tagClass:3,tagNumber:o.context}}))}else{this.cache(o.type);const h=!!o.repeated;let u=h?c:this.get(o.type,!0).schema;u="valueBlock"in u?u.valueBlock.value:u.value,s.push(new _({name:h?"":a,optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:u}))}else s.push(new _({optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:[c]}));else c.optional=l,s.push(c)}switch(r.type){case R.Sequence:return new he({value:s,name:""});case R.Set:return new fe({value:s,name:""});case R.Choice:return new Jt({value:s,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);return t?this.items.get(t)||this.findParentSchema(t):null}}const G=new Nn,je=i=>e=>{let t;G.has(e)?t=G.get(e):(t=G.createDefault(e),G.set(e,t)),Object.assign(t,i)},S=i=>(e,t)=>{let r;G.has(e.constructor)?r=G.get(e.constructor):(r=G.createDefault(e.constructor),G.set(e.constructor,r));const s=Object.assign({},i);if(typeof s.type=="number"&&!s.converter){const n=zt(i.type);if(!n)throw new Error(`Cannot get default converter for property '${t}' of ${e.constructor.name}`);s.converter=n}r.items[t]=s};class ir extends Error{constructor(){super(...arguments),this.schemas=[]}}class x{static parse(e,t){const r=Ke(e);if(r.result.error)throw new Error(r.result.error);return this.fromASN(r.result,t)}static fromASN(e,t){var r;try{if(ue(t))return new t().fromASN(e);const s=G.get(t);G.cache(t);let n=s.schema;if(e.constructor===_&&s.type!==R.Choice){n=new _({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:s.schema.valueBlock.value});for(const c in s.items)delete e[c]}const o=we({},e,n);if(!o.verified)throw new ir(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=new t;if(ys(t)){if(!("value"in e.valueBlock&&Array.isArray(e.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const c=s.itemType;if(typeof c=="number"){const l=zt(c);if(!l)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,h=>l.fromASN(h))}else return t.from(e.valueBlock.value,l=>this.fromASN(l,c))}for(const c in s.items){const l=o.result[c];if(!l)continue;const h=s.items[c],u=h.type;if(typeof u=="number"||ue(u)){const w=(r=h.converter)!==null&&r!==void 0?r:ue(u)?new u:null;if(!w)throw new Error("Converter is empty");if(h.repeated)if(h.implicit){const B=h.repeated==="sequence"?he:fe,C=new B;C.valueBlock=l.valueBlock;const P=Ke(C.toBER(!1));if(P.offset===-1)throw new Error(`Cannot parse the child item. ${P.result.error}`);if(!("value"in P.result.valueBlock&&Array.isArray(P.result.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const N=P.result.valueBlock.value;a[c]=Array.from(N,Y=>w.fromASN(Y))}else a[c]=Array.from(l,B=>w.fromASN(B));else{let B=l;if(h.implicit){let C;if(ue(u))C=new u().toSchema("");else{const P=g[u],N=fs[P];if(!N)throw new Error(`Cannot get '${P}' class from asn1js module`);C=new N}C.valueBlock=B.valueBlock,B=Ke(C.toBER(!1)).result}a[c]=w.fromASN(B)}}else if(h.repeated){if(!Array.isArray(l))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[c]=Array.from(l,w=>this.fromASN(w,u))}else a[c]=this.fromASN(l,u)}return a}catch(s){throw s instanceof ir&&s.schemas.push(t.name),s}}}class K{static serialize(e){return e instanceof O?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&typeof e=="object"&&ue(e))return e.toASN();if(!(e&&typeof e=="object"))throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,r=G.get(t);G.cache(t);let s=[];if(r.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if(typeof r.itemType=="number"){const o=zt(r.itemType);if(!o)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);s=e.map(a=>o.toASN(a))}else s=e.map(o=>this.toAsnItem({type:r.itemType},"[]",t,o))}else for(const o in r.items){const a=r.items[o],c=e[o];if(c===void 0||a.defaultValue===c||typeof a.defaultValue=="object"&&typeof c=="object"&&Cn(this.serialize(a.defaultValue),this.serialize(c)))continue;const l=K.toAsnItem(a,o,t,c);if(typeof a.context=="number")if(a.implicit)if(!a.repeated&&(typeof a.type=="number"||ue(a.type))){const h={};h.valueHex=l instanceof ke?l.valueBeforeDecodeView:l.valueBlock.toBER(),s.push(new Je({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},...h}))}else s.push(new _({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:l.valueBlock.value}));else s.push(new _({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[l]}));else a.repeated?s=s.concat(l):s.push(l)}let n;switch(r.type){case R.Sequence:n=new he({value:s});break;case R.Set:n=new fe({value:s});break;case R.Choice:if(!s[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);n=s[0];break}return n}static toAsnItem(e,t,r,s){let n;if(typeof e.type=="number"){const o=e.converter;if(!o)throw new Error(`Property '${t}' doesn't have converter for type ${g[e.type]} in schema '${r.name}'`);if(e.repeated){if(!Array.isArray(s))throw new TypeError("Parameter 'objProp' should be type of Array.");const a=Array.from(s,l=>o.toASN(l)),c=e.repeated==="sequence"?he:fe;n=new c({value:a})}else n=o.toASN(s)}else if(e.repeated){if(!Array.isArray(s))throw new TypeError("Parameter 'objProp' should be type of Array.");const o=Array.from(s,c=>this.toASN(c)),a=e.repeated==="sequence"?he:fe;n=new a({value:o})}else n=this.toASN(s);return n}}class jt{static serialize(e){return K.serialize(e)}static parse(e,t){return x.parse(e,t)}static toString(e){const t=p.isBufferSource(e)?p.toArrayBuffer(e):jt.serialize(e),r=Ke(t);if(r.offset===-1)throw new Error(`Cannot decode ASN.1 data. ${r.result.error}`);return r.result.toString()}}function k(i,e,t,r){var s=arguments.length,n=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")n=Reflect.decorate(i,e,t,r);else for(var a=i.length-1;a>=0;a--)(o=i[a])&&(n=(s<3?o(n):s>3?o(e,t,n):o(e,t))||n);return s>3&&n&&Object.defineProperty(e,t,n),n}class bt extends Error{constructor(e,t){super(t?`${e}. See the inner exception for more details.`:e),this.message=e,this.innerError=t}}class Un extends bt{constructor(e,t,r){super(t,r),this.schema=e}}class We extends Un{constructor(e,t,r){super(e,`JSON doesn't match to '${e.target.name}' schema. ${t}`,r)}}class me extends bt{}class Ct extends bt{constructor(e,t,r){super(`Cannot serialize by '${e}' schema. ${t}`,r),this.schemaName=e}}class or extends We{constructor(e,t,r={}){super(e,"Some keys doesn't match to schema"),this.keys=t,this.errors=r}}var I;(function(i){i[i.Any=0]="Any",i[i.Boolean=1]="Boolean",i[i.Number=2]="Number",i[i.String=3]="String"})(I||(I={}));function In(i,e){switch(e){case I.Boolean:return typeof i=="boolean";case I.Number:return typeof i=="number";case I.String:return typeof i=="string"}return!0}function kt(i,e){if(!In(i,e))throw new TypeError(`Value must be ${I[e]}`)}function Bt(i){return i&&i.prototype?i.prototype.toJSON&&i.prototype.fromJSON?!0:Bt(i.prototype):!!(i&&i.toJSON&&i.fromJSON)}class Pn{constructor(){this.items=new Map}has(e){return this.items.has(e)||!!this.findParentSchema(e)}get(e){const t=this.items.get(e)||this.findParentSchema(e);if(!t)throw new Error("Cannot get schema for current target");return t}create(e){const t={names:{}},r=this.findParentSchema(e);if(r){Object.assign(t,r),t.names={};for(const s in r.names)t.names[s]=Object.assign({},r.names[s])}return t.target=e,t}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=e.__proto__;return t?this.items.get(t)||this.findParentSchema(t):null}}const Me="default",X=new Pn;class Vn{constructor(e){this.pattern=new RegExp(e)}validate(e){const t=new RegExp(this.pattern.source,this.pattern.flags);if(typeof e!="string")throw new me("Incoming value must be string");if(!t.exec(e))throw new me(`Value doesn't match to pattern '${t.toString()}'`)}}class Hn{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(kt(e,I.Number),!(this.min<=e&&e<=this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new me(`Value doesn't match to diapason [${t},${r}]`)}}}class On{constructor(e=Number.MIN_VALUE,t=Number.MAX_VALUE){this.min=e,this.max=t}validate(e){if(kt(e,I.Number),!(this.min<e&&e<this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min,r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new me(`Value doesn't match to diapason (${t},${r})`)}}}class ds{constructor(e,t,r){this.length=e,this.minLength=t,this.maxLength=r}validate(e){if(this.length!==void 0){if(e.length!==this.length)throw new me(`Value length must be exactly ${this.length}.`);return}if(this.minLength!==void 0&&e.length<this.minLength)throw new me(`Value length must be more than ${this.minLength}.`);if(this.maxLength!==void 0&&e.length>this.maxLength)throw new me(`Value length must be less than ${this.maxLength}.`)}}class Rn{constructor(e){this.enumeration=e}validate(e){if(kt(e,I.String),!this.enumeration.includes(e))throw new me(`Value must be one of ${this.enumeration.map(t=>`'${t}'`).join(", ")}`)}}class ps{static checkValues(e,t){const r=Array.isArray(e)?e:[e];for(const s of r)for(const n of t.validations)n instanceof ds&&t.repeated?n.validate(e):n.validate(s)}static checkTypes(e,t){if(t.repeated&&!Array.isArray(e))throw new TypeError("Value must be Array");if(typeof t.type=="number"){const r=Array.isArray(e)?e:[e];for(const s of r)kt(s,t.type)}}static getSchemaByName(e,t=Me){return{...e.names[Me],...e.names[t]}}}class te extends ps{static serialize(e,t,r,s){const n=this.toJSON(e,t);return JSON.stringify(n,r,s)}static toJSON(e,t={}){let r,s=t.targetSchema;const n=t.schemaName||Me;if(Bt(e))return e.toJSON();if(Array.isArray(e)){r=[];for(const o of e)r.push(this.toJSON(o,t))}else if(typeof e=="object"){if(s&&!X.has(s))throw new bt("Cannot get schema for `targetSchema` param");if(s=s||e.constructor,X.has(s)){const o=X.get(s);r={};const a=this.getSchemaByName(o,n);for(const c in a)try{const l=a[c],h=e[c];let u;if(l.optional&&h===void 0||l.defaultValue!==void 0&&h===l.defaultValue)continue;if(!l.optional&&h===void 0)throw new Ct(s.name,`Property '${c}' is required.`);typeof l.type=="number"?l.converter?l.repeated?u=h.map(w=>l.converter.toJSON(w,e)):u=l.converter.toJSON(h,e):u=h:l.repeated?u=h.map(w=>this.toJSON(w,{schemaName:n})):u=this.toJSON(h,{schemaName:n}),this.checkTypes(u,l),this.checkValues(u,l),r[l.name||c]=u}catch(l){throw l instanceof Ct?l:new Ct(o.target.name,`Property '${c}' is wrong. ${l.message}`,l)}}else{r={};for(const o in e)r[o]=this.toJSON(e[o],{schemaName:n})}}else r=e;return r}}class D extends ps{static parse(e,t){const r=JSON.parse(e);return this.fromJSON(r,t)}static fromJSON(e,t){const r=t.targetSchema,s=t.schemaName||Me,n=new r;if(Bt(n))return n.fromJSON(e);const o=X.get(r),a=this.getSchemaByName(o,s),c={};t.strictProperty&&!Array.isArray(e)&&D.checkStrictProperty(e,a,o);for(const h in a)try{const u=a[h],w=u.name||h,B=e[w];if(B===void 0&&(u.optional||u.defaultValue!==void 0))continue;if(!u.optional&&B===void 0)throw new We(o,`Property '${w}' is required.`);if(this.checkTypes(B,u),this.checkValues(B,u),typeof u.type=="number")u.converter?u.repeated?n[h]=B.map(C=>u.converter.fromJSON(C,n)):n[h]=u.converter.fromJSON(B,n):n[h]=B;else{const C={...t,targetSchema:u.type,schemaName:s};u.repeated?n[h]=B.map(P=>this.fromJSON(P,C)):n[h]=this.fromJSON(B,C)}}catch(u){if(u instanceof We||(u=new We(o,`Property '${h}' is wrong. ${u.message}`,u)),t.strictAllKeys)c[h]=u;else throw u}const l=Object.keys(c);if(l.length)throw new or(o,l,c);return n}static checkStrictProperty(e,t,r){const s=Object.keys(e),n=Object.keys(t),o=[];for(const a of s)n.indexOf(a)===-1&&o.push(a);if(o.length)throw new or(r,o)}}function Ln(i){const e=[];return i.pattern&&e.push(new Vn(i.pattern)),(i.type===I.Number||i.type===I.Any)&&((i.minInclusive!==void 0||i.maxInclusive!==void 0)&&e.push(new Hn(i.minInclusive,i.maxInclusive)),(i.minExclusive!==void 0||i.maxExclusive!==void 0)&&e.push(new On(i.minExclusive,i.maxExclusive)),i.enumeration!==void 0&&e.push(new Rn(i.enumeration))),(i.type===I.String||i.repeated||i.type===I.Any)&&(i.length!==void 0||i.minLength!==void 0||i.maxLength!==void 0)&&e.push(new ds(i.length,i.minLength,i.maxLength)),e}const H=(i={})=>(e,t)=>{const r=`Cannot set type for ${t} property of ${e.constructor.name} schema`;let s;X.has(e.constructor)?(s=X.get(e.constructor),s.target!==e.constructor&&(s=X.create(e.constructor),X.set(e.constructor,s))):(s=X.create(e.constructor),X.set(e.constructor,s));const n={type:I.Any,validations:[]},o=Object.assign(n,i);if(o.validations=Ln(o),typeof o.type!="number"&&!X.has(o.type)&&!Bt(o.type))throw new Error(`${r}. Assigning type doesn't have schema.`);let a;Array.isArray(i.schema)?a=i.schema:a=[i.schema||Me];for(const c of a){s.names[c]||(s.names[c]={});const l=s.names[c];l[t]=o}};/*!
 Copyright (c) Peculiar Ventures, LLC
*/class oe extends Error{}class St extends oe{}class le extends oe{constructor(e){super(`Unsupported operation: ${e?`${e}`:""}`)}}class A extends oe{}class Dn extends oe{constructor(e){super(`${e}: Missing required property`)}}function Tn(i){return typeof i=="object"&&"kty"in i}class L{async digest(...e){return this.checkDigest.apply(this,e),this.onDigest.apply(this,e)}checkDigest(e,t){this.checkAlgorithmName(e)}async onDigest(e,t){throw new le("digest")}async generateKey(...e){return this.checkGenerateKey.apply(this,e),this.onGenerateKey.apply(this,e)}checkGenerateKey(e,t,r,...s){if(this.checkAlgorithmName(e),this.checkGenerateKeyParams(e),!(r&&r.length))throw new TypeError("Usages cannot be empty when creating a key.");let n;Array.isArray(this.usages)?n=this.usages:n=this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,n)}checkGenerateKeyParams(e){}async onGenerateKey(e,t,r,...s){throw new le("generateKey")}async sign(...e){return this.checkSign.apply(this,e),this.onSign.apply(this,e)}checkSign(e,t,r,...s){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"sign")}async onSign(e,t,r,...s){throw new le("sign")}async verify(...e){return this.checkVerify.apply(this,e),this.onVerify.apply(this,e)}checkVerify(e,t,r,s,...n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,"verify")}async onVerify(e,t,r,s,...n){throw new le("verify")}async encrypt(...e){return this.checkEncrypt.apply(this,e),this.onEncrypt.apply(this,e)}checkEncrypt(e,t,r,s={},...n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,s.keyUsage?"encrypt":void 0)}async onEncrypt(e,t,r,...s){throw new le("encrypt")}async decrypt(...e){return this.checkDecrypt.apply(this,e),this.onDecrypt.apply(this,e)}checkDecrypt(e,t,r,s={},...n){this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,s.keyUsage?"decrypt":void 0)}async onDecrypt(e,t,r,...s){throw new le("decrypt")}async deriveBits(...e){return this.checkDeriveBits.apply(this,e),this.onDeriveBits.apply(this,e)}checkDeriveBits(e,t,r,s={},...n){if(this.checkAlgorithmName(e),this.checkAlgorithmParams(e),this.checkCryptoKey(t,s.keyUsage?"deriveBits":void 0),r%8!==0)throw new A("length: Is not multiple of 8")}async onDeriveBits(e,t,r,...s){throw new le("deriveBits")}async exportKey(...e){return this.checkExportKey.apply(this,e),this.onExportKey.apply(this,e)}checkExportKey(e,t,...r){if(this.checkKeyFormat(e),this.checkCryptoKey(t),!t.extractable)throw new oe("key: Is not extractable")}async onExportKey(e,t,...r){throw new le("exportKey")}async importKey(...e){return this.checkImportKey.apply(this,e),this.onImportKey.apply(this,e)}checkImportKey(e,t,r,s,n,...o){this.checkKeyFormat(e),this.checkKeyData(e,t),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(n,this.usages)}async onImportKey(e,t,r,s,n,...o){throw new le("importKey")}checkAlgorithmName(e){if(e.name.toLowerCase()!==this.name.toLowerCase())throw new St("Unrecognized name")}checkAlgorithmParams(e){}checkDerivedKeyParams(e){}checkKeyUsages(e,t){for(const r of e)if(t.indexOf(r)===-1)throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(e,t){if(this.checkAlgorithmName(e.algorithm),t&&e.usages.indexOf(t)===-1)throw new oe("key does not match that of operation")}checkRequiredProperty(e,t){if(!(t in e))throw new Dn(t)}checkHashAlgorithm(e,t){for(const r of t)if(r.toLowerCase()===e.name.toLowerCase())return;throw new A(`hash: Must be one of ${t.join(", ")}`)}checkImportParams(e){}checkKeyFormat(e){switch(e){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(e,t){if(!t)throw new TypeError("keyData: Cannot be empty on empty on key importing");if(e==="jwk"){if(!Tn(t))throw new TypeError("keyData: Is not JsonWebToken")}else if(!p.isBufferSource(t))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer")}prepareData(e){return p.toArrayBuffer(e)}}class He extends L{checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),typeof e.length!="number")throw new TypeError("length: Is not of type Number");switch(e.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class $n extends He{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==16)throw new TypeError("iv: Must have length 16 bytes")}}class Mn extends He{constructor(){super(...arguments),this.name="AES-CMAC",this.usages=["sign","verify"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"length"),typeof e.length!="number")throw new TypeError("length: Is not a Number");if(e.length<1)throw new A("length: Must be more than 0")}}class _n extends He{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"counter"),!(e.counter instanceof ArrayBuffer||ArrayBuffer.isView(e.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.counter.byteLength!==16)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(e,"length"),typeof e.length!="number")throw new TypeError("length: Is not a Number");if(e.length<1)throw new A("length: Must be more than 0")}}class Jn extends He{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class Fn extends He{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength<1)throw new A("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in e||(e.tagLength=128),e.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new A("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class zn extends He{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class gs extends L{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(e){if(this.ivSize){if(this.checkRequiredProperty(e,"iv"),!(e.iv instanceof ArrayBuffer||ArrayBuffer.isView(e.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(e.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"length"),typeof e.length!="number")throw new TypeError("length: Is not of type Number");if(e.length!==this.keySizeBits)throw new A(`algorithm.length: Must be ${this.keySizeBits}`)}checkDerivedKeyParams(e){this.checkGenerateKeyParams(e)}}class Gt extends L{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=v.ToBase64(e.publicExponent);if(!(t==="Aw=="||t==="AQAB"))throw new TypeError("publicExponent: Must be [3] or [1,0,1]");if(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength%8||e.modulusLength<256||e.modulusLength>16384)throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384")}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class jn extends Gt{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class Gn extends Gt{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"saltLength"),typeof e.saltLength!="number")throw new TypeError("saltLength: Is not a Number");if(e.saltLength<0)throw new RangeError("saltLength: Must be positive number")}}class qn extends Gt{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(e){if(e.label&&!(e.label instanceof ArrayBuffer||ArrayBuffer.isView(e.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class qt extends L{checkGenerateKeyParams(e){this.checkRequiredProperty(e,"namedCurve"),this.checkNamedCurve(e.namedCurve)}checkNamedCurve(e){for(const t of this.namedCurves)if(t.toLowerCase()===e.toLowerCase())return;throw new A(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}class Wn extends qt{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}const Yn=["secret","private","public"];class Et{static create(e,t,r,s){const n=new this;return n.algorithm=e,n.type=t,n.extractable=r,n.usages=s,n}static isKeyType(e){return Yn.indexOf(e)!==-1}get[Symbol.toStringTag](){return"CryptoKey"}}class ms extends qt{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"public"),!(e.public instanceof Et))throw new TypeError("public: Is not a CryptoKey");if(e.public.type!=="public")throw new A("public: Is not a public key");if(e.public.algorithm.name!==this.name)throw new A(`public: Is not ${this.name} key`)}}class Xn extends ms{constructor(){super(...arguments),this.name="ECDH-ES",this.namedCurves=["X25519","X448"]}}class Zn extends qt{constructor(){super(...arguments),this.name="EdDSA",this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["Ed25519","Ed448"]}}let _e=class{constructor(e){e&&(this.value=e)}};k([S({type:g.ObjectIdentifier})],_e.prototype,"value",void 0);_e=k([je({type:R.Choice})],_e);class Ee{constructor(e){Object.assign(this,e)}}k([S({type:g.ObjectIdentifier})],Ee.prototype,"algorithm",void 0);k([S({type:g.Any,optional:!0})],Ee.prototype,"parameters",void 0);class Oe{constructor(){this.version=0,this.privateKeyAlgorithm=new Ee,this.privateKey=new ArrayBuffer(0)}}k([S({type:g.Integer})],Oe.prototype,"version",void 0);k([S({type:Ee})],Oe.prototype,"privateKeyAlgorithm",void 0);k([S({type:g.OctetString})],Oe.prototype,"privateKey",void 0);k([S({type:g.Any,optional:!0})],Oe.prototype,"attributes",void 0);class Wt{constructor(){this.publicKeyAlgorithm=new Ee,this.publicKey=new ArrayBuffer(0)}}k([S({type:Ee})],Wt.prototype,"publicKeyAlgorithm",void 0);k([S({type:g.BitString})],Wt.prototype,"publicKey",void 0);const re={fromJSON:i=>v.FromBase64Url(i),toJSON:i=>v.ToBase64Url(new Uint8Array(i))},ce={fromASN:i=>{const e=i.valueBlock.valueHex;return new Uint8Array(e)[0]?i.valueBlock.valueHex:i.valueBlock.valueHex.slice(1)},toASN:i=>{const e=new Uint8Array(i)[0]>127?dr(new Uint8Array([0]).buffer,i):i;return new q({valueHex:e})}};class se{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}k([S({type:g.Integer,converter:Ft})],se.prototype,"version",void 0);k([S({type:g.Integer,converter:ce}),H({name:"n",converter:re})],se.prototype,"modulus",void 0);k([S({type:g.Integer,converter:ce}),H({name:"e",converter:re})],se.prototype,"publicExponent",void 0);k([S({type:g.Integer,converter:ce}),H({name:"d",converter:re})],se.prototype,"privateExponent",void 0);k([S({type:g.Integer,converter:ce}),H({name:"p",converter:re})],se.prototype,"prime1",void 0);k([S({type:g.Integer,converter:ce}),H({name:"q",converter:re})],se.prototype,"prime2",void 0);k([S({type:g.Integer,converter:ce}),H({name:"dp",converter:re})],se.prototype,"exponent1",void 0);k([S({type:g.Integer,converter:ce}),H({name:"dq",converter:re})],se.prototype,"exponent2",void 0);k([S({type:g.Integer,converter:ce}),H({name:"qi",converter:re})],se.prototype,"coefficient",void 0);k([S({type:g.Any,optional:!0})],se.prototype,"otherPrimeInfos",void 0);class Yt{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}k([S({type:g.Integer,converter:ce}),H({name:"n",converter:re})],Yt.prototype,"modulus",void 0);k([S({type:g.Integer,converter:ce}),H({name:"e",converter:re})],Yt.prototype,"publicExponent",void 0);let Ne=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){let e=new Uint8Array(this.value);if(e[0]!==4)throw new oe("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");e=new Uint8Array(this.value.slice(1));const t=e.length/2,r=0;return{x:v.ToBase64Url(e.buffer.slice(r,r+t)),y:v.ToBase64Url(e.buffer.slice(r+t,r+t+t))}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");if(!("y"in e))throw new Error("y: Missing required property");const t=v.FromBase64Url(e.x),r=v.FromBase64Url(e.y),s=dr(new Uint8Array([4]).buffer,t,r);return this.value=new Uint8Array(s).buffer,this}};k([S({type:g.OctetString})],Ne.prototype,"value",void 0);Ne=k([je({type:R.Choice})],Ne);class Ge{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(e){if(!("d"in e))throw new Error("d: Missing required property");if(this.privateKey=v.FromBase64Url(e.d),"x"in e){const t=new Ne;t.fromJSON(e),this.publicKey=K.toASN(t).valueBlock.valueHex}return this}toJSON(){const e={};return e.d=v.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(e,new Ne(this.publicKey).toJSON()),e}}k([S({type:g.Integer,converter:Ft})],Ge.prototype,"version",void 0);k([S({type:g.OctetString})],Ge.prototype,"privateKey",void 0);k([S({context:0,type:g.Any,optional:!0})],Ge.prototype,"parameters",void 0);k([S({context:1,type:g.BitString,optional:!0})],Ge.prototype,"publicKey",void 0);const Xt={fromASN:i=>{const e=new Uint8Array(i.valueBlock.valueHex);return e[0]===0?e.buffer.slice(1):e.buffer},toASN:i=>{const e=new Uint8Array(i);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new q({valueHex:t.buffer})}return new q({valueHex:i})}};var Qn=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:Xt});class Ze{static decodePoint(e,t){const r=p.toUint8Array(e);if(r.length===0||r[0]!==4)throw new Error("Only uncompressed point format supported");const s=(r.length-1)/2;if(s!==Math.ceil(t/8))throw new Error("Point does not match field size");const n=r.slice(1,s+1),o=r.slice(s+1,s+1+s);return{x:n,y:o}}static encodePoint(e,t){const r=Math.ceil(t/8);if(e.x.byteLength!==r||e.y.byteLength!==r)throw new Error("X,Y coordinates don't match point size criteria");const s=p.toUint8Array(e.x),n=p.toUint8Array(e.y),o=new Uint8Array(r*2+1);return o[0]=4,o.set(s,1),o.set(n,r+1),o}static getSize(e){return Math.ceil(e/8)}static encodeSignature(e,t){const r=this.getSize(t),s=p.toUint8Array(e.r),n=p.toUint8Array(e.s),o=new Uint8Array(r*2);return o.set(this.padStart(s,r)),o.set(this.padStart(n,r),r),o}static decodeSignature(e,t){const r=this.getSize(t),s=p.toUint8Array(e);if(s.length!==r*2)throw new Error("Incorrect size of the signature");const n=s.slice(0,r),o=s.slice(r);return{r:this.trimStart(n),s:this.trimStart(o)}}static trimStart(e){let t=0;for(;t<e.length-1&&e[t]===0;)t++;return t===0?e:e.slice(t,e.length)}static padStart(e,t){if(t===e.length)return e;const r=new Uint8Array(t);return r.set(e,t-e.length),r}}class qe{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(e){const t=e.byteLength/2,r=Ze.decodeSignature(e,t*8),s=new qe;return s.r=p.toArrayBuffer(r.r),s.s=p.toArrayBuffer(r.s),s}toWebCryptoSignature(e){return e??(e=Math.max(this.r.byteLength,this.s.byteLength)*8),Ze.encodeSignature(this,e).buffer}}k([S({type:g.Integer,converter:Xt})],qe.prototype,"r",void 0);k([S({type:g.Integer,converter:Xt})],qe.prototype,"s",void 0);class ws extends Oe{}k([S({context:1,implicit:!0,type:g.BitString,optional:!0})],ws.prototype,"publicKey",void 0);let Qe=class{constructor(){this.value=new ArrayBuffer(0)}fromJSON(e){if(!e.d)throw new Error("d: Missing required property");return this.value=v.FromBase64Url(e.d),this}toJSON(){return{d:v.ToBase64Url(this.value)}}};k([S({type:g.OctetString})],Qe.prototype,"value",void 0);Qe=k([je({type:R.Choice})],Qe);let et=class{constructor(e){this.value=new ArrayBuffer(0),e&&(this.value=e)}toJSON(){return{x:v.ToBase64Url(this.value)}}fromJSON(e){if(!("x"in e))throw new Error("x: Missing required property");return this.value=v.FromBase64Url(e.x),this}};k([S({type:g.BitString})],et.prototype,"value",void 0);et=k([je({type:R.Choice})],et);let tt=class{};k([S({type:g.OctetString}),H({type:I.String,converter:re})],tt.prototype,"d",void 0);tt=k([je({type:R.Choice})],tt);const vs="1.2.840.10045.3.1.7",xt="1.3.132.0",As=`${xt}.34`,bs=`${xt}.35`,ks=`${xt}.10`,$="1.3.36.3.3.2.8.1.1",Bs=`${$}.1`,Ss=`${$}.2`,Es=`${$}.3`,xs=`${$}.4`,Ks=`${$}.5`,Cs=`${$}.6`,Ns=`${$}.7`,Us=`${$}.8`,Is=`${$}.9`,Ps=`${$}.10`,Vs=`${$}.11`,Hs=`${$}.12`,Os=`${$}.13`,Rs=`${$}.14`,ei="1.3.101.110",ti="1.3.101.111",ri="1.3.101.112",si="1.3.101.113";var d=Object.freeze({__proto__:null,converters:Qn,get ObjectIdentifier(){return _e},AlgorithmIdentifier:Ee,PrivateKeyInfo:Oe,PublicKeyInfo:Wt,RsaPrivateKey:se,RsaPublicKey:Yt,EcPrivateKey:Ge,get EcPublicKey(){return Ne},EcDsaSignature:qe,OneAsymmetricKey:ws,get EdPrivateKey(){return Qe},get EdPublicKey(){return et},get CurvePrivateKey(){return tt},idSecp256r1:vs,idEllipticCurve:xt,idSecp384r1:As,idSecp521r1:bs,idSecp256k1:ks,idVersionOne:$,idBrainpoolP160r1:Bs,idBrainpoolP160t1:Ss,idBrainpoolP192r1:Es,idBrainpoolP192t1:xs,idBrainpoolP224r1:Ks,idBrainpoolP224t1:Cs,idBrainpoolP256r1:Ns,idBrainpoolP256t1:Us,idBrainpoolP320r1:Is,idBrainpoolP320t1:Ps,idBrainpoolP384r1:Vs,idBrainpoolP384t1:Hs,idBrainpoolP512r1:Os,idBrainpoolP512t1:Rs,idX25519:ei,idX448:ti,idEd25519:ri,idEd448:si});class U{constructor(){}static register(e){const t=new _e;t.value=e.id;const r=jt.serialize(t);this.items.push({...e,raw:r}),this.names.push(e.name)}static find(e){e=e.toUpperCase();for(const t of this.items)if(t.name.toUpperCase()===e||t.id.toUpperCase()===e)return t;return null}static get(e){const t=this.find(e);if(!t)throw new Error(`Unsupported EC named curve '${e}'`);return t}}U.items=[];U.names=[];U.register({name:"P-256",id:vs,size:256});U.register({name:"P-384",id:As,size:384});U.register({name:"P-521",id:bs,size:521});U.register({name:"K-256",id:ks,size:256});U.register({name:"brainpoolP160r1",id:Bs,size:160});U.register({name:"brainpoolP160t1",id:Ss,size:160});U.register({name:"brainpoolP192r1",id:Es,size:192});U.register({name:"brainpoolP192t1",id:xs,size:192});U.register({name:"brainpoolP224r1",id:Ks,size:224});U.register({name:"brainpoolP224t1",id:Cs,size:224});U.register({name:"brainpoolP256r1",id:Ns,size:256});U.register({name:"brainpoolP256t1",id:Us,size:256});U.register({name:"brainpoolP320r1",id:Is,size:320});U.register({name:"brainpoolP320t1",id:Ps,size:320});U.register({name:"brainpoolP384r1",id:Vs,size:384});U.register({name:"brainpoolP384t1",id:Hs,size:384});U.register({name:"brainpoolP512r1",id:Os,size:512});U.register({name:"brainpoolP512t1",id:Rs,size:512});class ni extends L{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(e){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${e}'`)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),"length"in e){if(typeof e.length!="number")throw new TypeError("length: Is not a Number");if(e.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(e){this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms)}}class ii extends L{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!(e.salt instanceof ArrayBuffer||ArrayBuffer.isView(e.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"iterations"),typeof e.iterations!="number")throw new TypeError("iterations: Is not a Number");if(e.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(e,t,r,s,n,...o){if(super.checkImportKey(e,t,r,s,n),s)throw new SyntaxError("extractable: Must be 'false'")}}class oi extends L{constructor(){super(...arguments),this.name="HKDF",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveKey","deriveBits"]}checkAlgorithmParams(e){if(this.checkRequiredProperty(e,"hash"),this.checkHashAlgorithm(e.hash,this.hashAlgorithms),this.checkRequiredProperty(e,"salt"),!p.isBufferSource(e.salt))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(e,"info"),!p.isBufferSource(e.info))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}checkImportKey(e,t,r,s,n,...o){if(super.checkImportKey(e,t,r,s,n),s)throw new SyntaxError("extractable: Must be 'false'")}}class Ls extends L{constructor(){super(...arguments),this.usages=[],this.defaultLength=0}digest(...e){return e[0]={length:this.defaultLength,...e[0]},super.digest.apply(this,e)}checkDigest(e,t){super.checkDigest(e,t);const r=e.length||0;if(typeof r!="number")throw new TypeError("length: Is not a Number");if(r<0)throw new TypeError("length: Is negative")}}class ai extends Ls{constructor(){super(...arguments),this.name="shake128",this.defaultLength=16}}class ci extends Ls{constructor(){super(...arguments),this.name="shake256",this.defaultLength=32}}class li{get[Symbol.toStringTag](){return"Crypto"}randomUUID(){const e=this.getRandomValues(new Uint8Array(16));e[6]=e[6]&15|64,e[8]=e[8]&63|128;const t=v.ToHex(e).toLowerCase();return`${t.substring(0,8)}-${t.substring(8,12)}-${t.substring(12,16)}-${t.substring(16)}`}}class ui{constructor(){this.items={}}get(e){return this.items[e.toLowerCase()]||null}set(e){this.items[e.name.toLowerCase()]=e}removeAt(e){const t=this.get(e.toLowerCase());return t&&delete this.items[e],t}has(e){return!!this.get(e)}get length(){return Object.keys(this.items).length}get algorithms(){const e=[];for(const t in this.items){const r=this.items[t];e.push(r.name)}return e.sort()}}class Zt{constructor(){this.providers=new ui}static isHashedAlgorithm(e){return!!(e&&typeof e=="object"&&"name"in e&&"hash"in e)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...e){this.checkRequiredArguments(e,2,"digest");const[t,r,...s]=e,n=this.prepareAlgorithm(t),o=p.toArrayBuffer(r);return await this.getProvider(n.name).digest(n,o,...s)}async generateKey(...e){this.checkRequiredArguments(e,3,"generateKey");const[t,r,s,...n]=e,o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.generateKey({...o,name:a.name},r,s,...n)}async sign(...e){this.checkRequiredArguments(e,3,"sign");const[t,r,s,...n]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=p.toArrayBuffer(s),c=this.getProvider(o.name);return await c.sign({...o,name:c.name},r,a,...n)}async verify(...e){this.checkRequiredArguments(e,4,"verify");const[t,r,s,n,...o]=e;this.checkCryptoKey(r);const a=this.prepareAlgorithm(t),c=p.toArrayBuffer(n),l=p.toArrayBuffer(s),h=this.getProvider(a.name);return await h.verify({...a,name:h.name},r,l,c,...o)}async encrypt(...e){this.checkRequiredArguments(e,3,"encrypt");const[t,r,s,...n]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=p.toArrayBuffer(s),c=this.getProvider(o.name);return await c.encrypt({...o,name:c.name},r,a,{keyUsage:!0},...n)}async decrypt(...e){this.checkRequiredArguments(e,3,"decrypt");const[t,r,s,...n]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=p.toArrayBuffer(s),c=this.getProvider(o.name);return await c.decrypt({...o,name:c.name},r,a,{keyUsage:!0},...n)}async deriveBits(...e){this.checkRequiredArguments(e,3,"deriveBits");const[t,r,s,...n]=e;this.checkCryptoKey(r);const o=this.prepareAlgorithm(t),a=this.getProvider(o.name);return await a.deriveBits({...o,name:a.name},r,s,{keyUsage:!0},...n)}async deriveKey(...e){this.checkRequiredArguments(e,5,"deriveKey");const[t,r,s,n,o,...a]=e,c=this.prepareAlgorithm(s);this.getProvider(c.name).checkDerivedKeyParams(c);const h=this.prepareAlgorithm(t),u=this.getProvider(h.name);u.checkCryptoKey(r,"deriveKey");const w=await u.deriveBits({...h,name:u.name},r,s.length||512,{keyUsage:!1},...a);return this.importKey("raw",w,s,n,o,...a)}async exportKey(...e){this.checkRequiredArguments(e,2,"exportKey");const[t,r,...s]=e;return this.checkCryptoKey(r),await this.getProvider(r.algorithm.name).exportKey(t,r,...s)}async importKey(...e){this.checkRequiredArguments(e,5,"importKey");const[t,r,s,n,o,...a]=e,c=this.prepareAlgorithm(s),l=this.getProvider(c.name);if(["pkcs8","spki","raw"].indexOf(t)!==-1){const h=p.toArrayBuffer(r);return l.importKey(t,h,{...c,name:l.name},n,o,...a)}else if(!r.kty)throw new TypeError("keyData: Is not JSON");return l.importKey(t,r,{...c,name:l.name},n,o,...a)}async wrapKey(e,t,r,s,...n){let o=await this.exportKey(e,t,...n);if(e==="jwk"){const h=JSON.stringify(o);o=v.FromUtf8String(h)}const a=this.prepareAlgorithm(s),c=p.toArrayBuffer(o),l=this.getProvider(a.name);return l.encrypt({...a,name:l.name},r,c,{keyUsage:!1},...n)}async unwrapKey(e,t,r,s,n,o,a,...c){const l=this.prepareAlgorithm(s),h=p.toArrayBuffer(t),u=this.getProvider(l.name);let w=await u.decrypt({...l,name:u.name},r,h,{keyUsage:!1},...c);if(e==="jwk")try{w=JSON.parse(v.ToUtf8String(w))}catch(B){const C=new TypeError("wrappedKey: Is not a JSON");throw C.internal=B,C}return this.importKey(e,w,n,o,a,...c)}checkRequiredArguments(e,t,r){if(e.length<t)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${t} arguments required, but only ${e.length} present`)}prepareAlgorithm(e){if(typeof e=="string")return{name:e};if(Zt.isHashedAlgorithm(e)){const t={...e};return t.hash=this.prepareAlgorithm(e.hash),t}return{...e}}getProvider(e){const t=this.providers.get(e);if(!t)throw new St("Unrecognized name");return t}checkCryptoKey(e){if(!(e instanceof Et))throw new TypeError("Key is not of type 'CryptoKey'")}}/*!
 Copyright (c) Peculiar Ventures, LLC
*/const Qt={fromJSON:i=>Buffer.from(v.FromBase64Url(i)),toJSON:i=>v.ToBase64Url(i)};class pe extends Et{constructor(){super(...arguments),this.data=Buffer.alloc(0),this.algorithm={name:""},this.extractable=!1,this.type="secret",this.usages=[],this.kty="oct",this.alg=""}}k([H({name:"ext",type:I.Boolean,optional:!0})],pe.prototype,"extractable",void 0);k([H({name:"key_ops",type:I.String,repeated:!0,optional:!0})],pe.prototype,"usages",void 0);k([H({type:I.String})],pe.prototype,"kty",void 0);k([H({type:I.String,optional:!0})],pe.prototype,"alg",void 0);class Ds extends pe{constructor(){super(...arguments),this.kty="oct",this.type="secret"}}class Re extends pe{}class j extends Ds{get alg(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-KW":return`A${this.algorithm.length}KW`;case"AES-CMAC":return`A${this.algorithm.length}CMAC`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new St("Unsupported algorithm name")}}set alg(e){}}k([H({name:"k",converter:Qt})],j.prototype,"data",void 0);const Ts=new WeakMap;function f(i){const e=Ts.get(i);if(!e)throw new A("Cannot get CryptoKey from secure storage");return e}function b(i){const e=Et.create(i.algorithm,i.type,i.extractable,i.usages);return Object.freeze(e),Ts.set(e,i),e}class E{static async generateKey(e,t,r){const s=new j;return s.algorithm=e,s.extractable=t,s.usages=r,s.data=m.randomBytes(e.length>>3),s}static async exportKey(e,t){if(!(t instanceof j))throw new Error("key: Is not AesCryptoKey");switch(e.toLowerCase()){case"jwk":return te.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new A("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,s,n){let o;switch(e.toLowerCase()){case"jwk":o=D.fromJSON(t,{targetSchema:j});break;case"raw":o=new j,o.data=Buffer.from(t);break;default:throw new A("format: Must be 'jwk' or 'raw'")}switch(o.algorithm=r,o.algorithm.length=o.data.length<<3,o.extractable=s,o.usages=n,o.algorithm.length){case 128:case 192:case 256:break;default:throw new A("keyData: Is wrong key length")}return o}static async encrypt(e,t,r){switch(e.name.toUpperCase()){case"AES-CBC":return this.encryptAesCBC(e,t,Buffer.from(r));case"AES-CTR":return this.encryptAesCTR(e,t,Buffer.from(r));case"AES-GCM":return this.encryptAesGCM(e,t,Buffer.from(r));case"AES-KW":return this.encryptAesKW(e,t,Buffer.from(r));case"AES-ECB":return this.encryptAesECB(e,t,Buffer.from(r));default:throw new A("algorithm: Is not recognized")}}static async decrypt(e,t,r){if(!(t instanceof j))throw new Error("key: Is not AesCryptoKey");switch(e.name.toUpperCase()){case"AES-CBC":return this.decryptAesCBC(e,t,Buffer.from(r));case"AES-CTR":return this.decryptAesCTR(e,t,Buffer.from(r));case"AES-GCM":return this.decryptAesGCM(e,t,Buffer.from(r));case"AES-KW":return this.decryptAesKW(e,t,Buffer.from(r));case"AES-ECB":return this.decryptAesECB(e,t,Buffer.from(r));default:throw new A("algorithm: Is not recognized")}}static async encryptAesCBC(e,t,r){const s=m.createCipheriv(`aes-${t.algorithm.length}-cbc`,t.data,new Uint8Array(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptAesCBC(e,t,r){const s=m.createDecipheriv(`aes-${t.algorithm.length}-cbc`,t.data,new Uint8Array(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async encryptAesCTR(e,t,r){const s=m.createCipheriv(`aes-${t.algorithm.length}-ctr`,t.data,Buffer.from(e.counter));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptAesCTR(e,t,r){const s=m.createDecipheriv(`aes-${t.algorithm.length}-ctr`,t.data,new Uint8Array(e.counter));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async encryptAesGCM(e,t,r){const s=m.createCipheriv(`aes-${t.algorithm.length}-gcm`,t.data,Buffer.from(e.iv),{authTagLength:(e.tagLength||128)>>3});e.additionalData&&s.setAAD(Buffer.from(e.additionalData));let n=s.update(r);return n=Buffer.concat([n,s.final(),s.getAuthTag()]),new Uint8Array(n).buffer}static async decryptAesGCM(e,t,r){const s=m.createDecipheriv(`aes-${t.algorithm.length}-gcm`,t.data,new Uint8Array(e.iv)),n=(e.tagLength||128)>>3,o=r.slice(0,r.length-n),a=r.slice(r.length-n);e.additionalData&&s.setAAD(Buffer.from(e.additionalData)),s.setAuthTag(a);let c=s.update(o);return c=Buffer.concat([c,s.final()]),new Uint8Array(c).buffer}static async encryptAesKW(e,t,r){const s=m.createCipheriv(`id-aes${t.algorithm.length}-wrap`,t.data,this.AES_KW_IV);let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptAesKW(e,t,r){const s=m.createDecipheriv(`id-aes${t.algorithm.length}-wrap`,t.data,this.AES_KW_IV);let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async encryptAesECB(e,t,r){const s=m.createCipheriv(`aes-${t.algorithm.length}-ecb`,t.data,new Uint8Array(0));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptAesECB(e,t,r){const s=m.createDecipheriv(`aes-${t.algorithm.length}-ecb`,t.data,new Uint8Array(0));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}}E.AES_KW_IV=Buffer.from("A6A6A6A6A6A6A6A6","hex");class hi extends $n{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onEncrypt(e,t,r){return E.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return E.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}const er=Buffer.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),ar=Buffer.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,135]),Ae=16;function cr(i){const e=Buffer.alloc(i.length),t=i.length-1;for(let r=0;r<t;r++)e[r]=i[r]<<1,i[r+1]&128&&(e[r]+=1);return e[t]=i[t]<<1,e}function xe(i,e){const t=Math.min(i.length,e.length),r=Buffer.alloc(t);for(let s=0;s<t;s++)r[s]=i[s]^e[s];return r}function Pt(i,e){const t=(void 0)(`aes${i.length<<3}`,i,er),r=t.update(e);return t.final(),r}function lr(i,e){const t=Buffer.alloc(Ae),r=e*Ae,s=r+Ae;return i.copy(t,0,r,s),t}function fi(i,e){const t=Buffer.alloc(Ae),r=e*Ae,s=i.length;return t.fill(0),i.copy(t,0,r,s),t[s-r]=128,t}function yi(i){const e=Pt(i,er);let t=cr(e);e[0]&128&&(t=xe(t,ar));let r=cr(t);return t[0]&128&&(r=xe(r,ar)),{subkey1:t,subkey2:r}}function di(i,e){const t=yi(i);let r=Math.ceil(e.length/Ae),s,n;r===0?(r=1,s=!1):s=e.length%Ae===0;const o=r-1;s?n=xe(lr(e,o),t.subkey1):n=xe(fi(e,o),t.subkey2);let a=er,c;for(let l=0;l<o;l++)c=xe(a,lr(e,l)),a=Pt(i,c);return c=xe(n,a),Pt(i,c)}class pi extends Mn{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onSign(e,t,r){const s=di(f(t).data,Buffer.from(r));return new Uint8Array(s).buffer}async onVerify(e,t,r,s){const n=await this.sign(e,t,s);return Buffer.from(r).compare(Buffer.from(n))===0}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}class gi extends _n{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onEncrypt(e,t,r){return E.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return E.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}class mi extends Fn{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onEncrypt(e,t,r){return E.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return E.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}class wi extends zn{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}async onEncrypt(e,t,r){return E.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return E.decrypt(e,f(t),new Uint8Array(r))}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}class vi extends Jn{async onGenerateKey(e,t,r){const s=await E.generateKey({name:this.name,length:e.length},t,r);return b(s)}async onEncrypt(e,t,r){return E.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return E.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return E.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await E.importKey(e,t,{name:r.name},s,n);return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof j))throw new TypeError("key: Is not a AesCryptoKey")}}class ve extends Ds{get alg(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new St("Unsupported algorithm name")}}set alg(e){}}k([H({name:"k",converter:Qt})],ve.prototype,"data",void 0);class ie{static async generateKey(e,t,r){const s=new ve;return s.algorithm=e,s.extractable=t,s.usages=r,s.data=m.randomBytes(e.length>>3),s}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return te.toJSON(t);case"raw":return new Uint8Array(t.data).buffer;default:throw new A("format: Must be 'jwk' or 'raw'")}}static async importKey(e,t,r,s,n){let o;switch(e.toLowerCase()){case"jwk":o=D.fromJSON(t,{targetSchema:ve});break;case"raw":o=new ve,o.data=Buffer.from(t);break;default:throw new A("format: Must be 'jwk' or 'raw'")}return o.algorithm=r,o.extractable=s,o.usages=n,o}static async encrypt(e,t,r){switch(e.name.toUpperCase()){case"DES-CBC":return this.encryptDesCBC(e,t,Buffer.from(r));case"DES-EDE3-CBC":return this.encryptDesEDE3CBC(e,t,Buffer.from(r));default:throw new A("algorithm: Is not recognized")}}static async decrypt(e,t,r){if(!(t instanceof ve))throw new Error("key: Is not DesCryptoKey");switch(e.name.toUpperCase()){case"DES-CBC":return this.decryptDesCBC(e,t,Buffer.from(r));case"DES-EDE3-CBC":return this.decryptDesEDE3CBC(e,t,Buffer.from(r));default:throw new A("algorithm: Is not recognized")}}static async encryptDesCBC(e,t,r){const s=m.createCipheriv("des-cbc",t.data,new Uint8Array(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptDesCBC(e,t,r){const s=m.createDecipheriv("des-cbc",t.data,new Uint8Array(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async encryptDesEDE3CBC(e,t,r){const s=m.createCipheriv("des-ede3-cbc",t.data,Buffer.from(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}static async decryptDesEDE3CBC(e,t,r){const s=m.createDecipheriv("des-ede3-cbc",t.data,new Uint8Array(e.iv));let n=s.update(r);return n=Buffer.concat([n,s.final()]),new Uint8Array(n).buffer}}class Ai extends gs{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}async onGenerateKey(e,t,r){const s=await ie.generateKey({name:this.name,length:this.keySizeBits},t,r);return b(s)}async onEncrypt(e,t,r){return ie.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return ie.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return ie.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await ie.importKey(e,t,{name:this.name,length:this.keySizeBits},s,n);if(o.data.length!==this.keySizeBits>>3)throw new A("keyData: Wrong key size");return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof ve))throw new TypeError("key: Is not a DesCryptoKey")}}class bi extends gs{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}async onGenerateKey(e,t,r){const s=await ie.generateKey({name:this.name,length:this.keySizeBits},t,r);return b(s)}async onEncrypt(e,t,r){return ie.encrypt(e,f(t),new Uint8Array(r))}async onDecrypt(e,t,r){return ie.decrypt(e,f(t),new Uint8Array(r))}async onExportKey(e,t){return ie.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await ie.importKey(e,t,{name:this.name,length:this.keySizeBits},s,n);if(o.data.length!==this.keySizeBits>>3)throw new A("keyData: Wrong key size");return b(o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof ve))throw new TypeError("key: Is not a DesCryptoKey")}}function $s(i){switch(i.name.toUpperCase()){case"RSA-OAEP":{const e=/(\d+)$/.exec(i.hash.name)[1];return`RSA-OAEP${e!=="1"?`-${e}`:""}`}case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(i.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(i.hash.name)[1]}`;case"RSA-PKCS1":return"RS1";default:throw new A("algorithm: Is not recognized")}}class Ue extends Re{constructor(){super(...arguments),this.type="private"}getKey(){const e=x.parse(this.data,d.PrivateKeyInfo);return x.parse(e.privateKey,d.RsaPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:$s(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,te.toJSON(e))}fromJSON(e){const t=D.fromJSON(e,{targetSchema:d.RsaPrivateKey}),r=new d.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.privateKeyAlgorithm.parameters=null,r.privateKey=K.serialize(t),this.data=Buffer.from(K.serialize(r))}}class Ie extends Re{constructor(){super(...arguments),this.type="public"}getKey(){const e=x.parse(this.data,d.PublicKeyInfo);return x.parse(e.publicKey,d.RsaPublicKey)}toJSON(){const e=this.getKey(),t={kty:"RSA",alg:$s(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(t,te.toJSON(e))}fromJSON(e){const t=D.fromJSON(e,{targetSchema:d.RsaPublicKey}),r=new d.PublicKeyInfo;r.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.publicKeyAlgorithm.parameters=null,r.publicKey=K.serialize(t),this.data=Buffer.from(K.serialize(r))}}class V{static async generateKey(e,t,r){const s=new Ue;s.algorithm=e,s.extractable=t,s.usages=r.filter(l=>this.privateKeyUsages.indexOf(l)!==-1);const n=new Ie;n.algorithm=e,n.extractable=!0,n.usages=r.filter(l=>this.publicKeyUsages.indexOf(l)!==-1);const o=Buffer.concat([Buffer.alloc(4-e.publicExponent.byteLength,0),Buffer.from(e.publicExponent)]).readInt32BE(0),a=m.generateKeyPairSync("rsa",{modulusLength:e.modulusLength,publicExponent:o,publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});return s.data=a.privateKey,n.data=a.publicKey,{privateKey:s,publicKey:n}}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return te.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;default:throw new A("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(e,t,r,s,n){switch(e.toLowerCase()){case"jwk":if(t.d){const a=D.fromJSON(t,{targetSchema:d.RsaPrivateKey});return this.importPrivateKey(a,r,s,n)}else{const a=D.fromJSON(t,{targetSchema:d.RsaPublicKey});return this.importPublicKey(a,r,s,n)}case"spki":{const o=x.parse(new Uint8Array(t),d.PublicKeyInfo),a=x.parse(o.publicKey,d.RsaPublicKey);return this.importPublicKey(a,r,s,n)}case"pkcs8":{const o=x.parse(new Uint8Array(t),d.PrivateKeyInfo),a=x.parse(o.privateKey,d.RsaPrivateKey);return this.importPrivateKey(a,r,s,n)}default:throw new A("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async sign(e,t,r){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.signRsa(e,t,r);default:throw new A("algorithm: Is not recognized")}}static async verify(e,t,r,s){switch(e.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.verifySSA(e,t,s,r);default:throw new A("algorithm: Is not recognized")}}static async encrypt(e,t,r){switch(e.name.toUpperCase()){case"RSA-OAEP":return this.encryptOAEP(e,t,r);default:throw new A("algorithm: Is not recognized")}}static async decrypt(e,t,r){switch(e.name.toUpperCase()){case"RSA-OAEP":return this.decryptOAEP(e,t,r);default:throw new A("algorithm: Is not recognized")}}static importPrivateKey(e,t,r,s){const n=new d.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.privateKeyAlgorithm.parameters=null,n.privateKey=K.serialize(e);const o=new Ue;return o.data=Buffer.from(K.serialize(n)),o.algorithm=Object.assign({},t),o.algorithm.publicExponent=new Uint8Array(e.publicExponent),o.algorithm.modulusLength=e.modulus.byteLength<<3,o.extractable=r,o.usages=s,o}static importPublicKey(e,t,r,s){const n=new d.PublicKeyInfo;n.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",n.publicKeyAlgorithm.parameters=null,n.publicKey=K.serialize(e);const o=new Ie;return o.data=Buffer.from(K.serialize(n)),o.algorithm=Object.assign({},t),o.algorithm.publicExponent=new Uint8Array(e.publicExponent),o.algorithm.modulusLength=e.modulus.byteLength<<3,o.extractable=r,o.usages=s,o}static getCryptoAlgorithm(e){switch(e.hash.name.toUpperCase()){case"SHA-1":return"RSA-SHA1";case"SHA-256":return"RSA-SHA256";case"SHA-384":return"RSA-SHA384";case"SHA-512":return"RSA-SHA512";case"SHA3-256":return"RSA-SHA3-256";case"SHA3-384":return"RSA-SHA3-384";case"SHA3-512":return"RSA-SHA3-512";default:throw new A("algorithm.hash: Is not recognized")}}static signRsa(e,t,r){const s=this.getCryptoAlgorithm(t.algorithm),n=m.createSign(s);n.update(Buffer.from(r)),t.pem||(t.pem=`-----BEGIN PRIVATE KEY-----
${t.data.toString("base64")}
-----END PRIVATE KEY-----`);const o={key:t.pem};e.name.toUpperCase()==="RSA-PSS"&&(o.padding=m.constants.RSA_PKCS1_PSS_PADDING,o.saltLength=e.saltLength);const a=n.sign(o);return new Uint8Array(a).buffer}static verifySSA(e,t,r,s){const n=this.getCryptoAlgorithm(t.algorithm),o=m.createVerify(n);o.update(Buffer.from(r)),t.pem||(t.pem=`-----BEGIN PUBLIC KEY-----
${t.data.toString("base64")}
-----END PUBLIC KEY-----`);const a={key:t.pem};return e.name.toUpperCase()==="RSA-PSS"&&(a.padding=m.constants.RSA_PKCS1_PSS_PADDING,a.saltLength=e.saltLength),o.verify(a,s)}static encryptOAEP(e,t,r){const s={key:`-----BEGIN PUBLIC KEY-----
${t.data.toString("base64")}
-----END PUBLIC KEY-----`,padding:m.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(m.publicEncrypt(s,r)).buffer}static decryptOAEP(e,t,r){const s={key:`-----BEGIN PRIVATE KEY-----
${t.data.toString("base64")}
-----END PRIVATE KEY-----`,padding:m.constants.RSA_PKCS1_OAEP_PADDING};return e.label,new Uint8Array(m.privateDecrypt(s,r)).buffer}}V.publicKeyUsages=["verify","encrypt","wrapKey"];V.privateKeyUsages=["sign","decrypt","unwrapKey"];class ki extends jn{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const s=await V.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onSign(e,t,r){return V.sign(e,f(t),new Uint8Array(r))}async onVerify(e,t,r,s){return V.verify(e,f(t),new Uint8Array(r),new Uint8Array(s))}async onExportKey(e,t){return V.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await V.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof Ue||r instanceof Ie))throw new TypeError("key: Is not RSA CryptoKey")}}class Bi extends Gn{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const s=await V.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onSign(e,t,r){return V.sign(e,f(t),new Uint8Array(r))}async onVerify(e,t,r,s){return V.verify(e,f(t),new Uint8Array(r),new Uint8Array(s))}async onExportKey(e,t){return V.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await V.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof Ue||r instanceof Ie))throw new TypeError("key: Is not RSA CryptoKey")}}class J{static size(e){switch(e.name.toUpperCase()){case"SHA-1":return 160;case"SHA-256":case"SHA3-256":return 256;case"SHA-384":case"SHA3-384":return 384;case"SHA-512":case"SHA3-512":return 512;default:throw new Error("Unrecognized name")}}static getAlgorithmName(e){switch(e.name.toUpperCase()){case"SHA-1":return"sha1";case"SHA-256":return"sha256";case"SHA-384":return"sha384";case"SHA-512":return"sha512";case"SHA3-256":return"sha3-256";case"SHA3-384":return"sha3-384";case"SHA3-512":return"sha3-512";default:throw new Error("Unrecognized name")}}static digest(e,t){const r=this.getAlgorithmName(e),s=m.createHash(r).update(Buffer.from(t)).digest();return new Uint8Array(s).buffer}}class Si extends qn{async onGenerateKey(e,t,r){const s=await V.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onEncrypt(e,t,r){const s=f(t),n=new Uint8Array(r),o=Math.ceil(s.algorithm.modulusLength>>3),a=J.size(s.algorithm.hash)>>3,c=n.byteLength,l=o-c-2*a-2;if(c>o-2*a-2)throw new Error("Data too large");const h=new Uint8Array(o),u=h.subarray(1,a+1),w=h.subarray(a+1);w.set(n,a+l+1);const B=m.createHash(s.algorithm.hash.name.replace("-","")).update(p.toUint8Array(e.label||new Uint8Array(0))).digest();w.set(B,0),w[a+l]=1,m.randomFillSync(u);const C=this.mgf1(s.algorithm.hash,u,w.length);for(let Y=0;Y<w.length;Y++)w[Y]^=C[Y];const P=this.mgf1(s.algorithm.hash,w,u.length);for(let Y=0;Y<u.length;Y++)u[Y]^=P[Y];s.pem||(s.pem=`-----BEGIN PUBLIC KEY-----
${s.data.toString("base64")}
-----END PUBLIC KEY-----`);const N=m.publicEncrypt({key:s.pem,padding:m.constants.RSA_NO_PADDING},Buffer.from(h));return new Uint8Array(N).buffer}async onDecrypt(e,t,r){const s=f(t),n=Math.ceil(s.algorithm.modulusLength>>3),o=J.size(s.algorithm.hash)>>3;if(r.byteLength!==n)throw new Error("Bad data");s.pem||(s.pem=`-----BEGIN PRIVATE KEY-----
${s.data.toString("base64")}
-----END PRIVATE KEY-----`);let c=m.privateDecrypt({key:s.pem,padding:m.constants.RSA_NO_PADDING},Buffer.from(r));const l=c[0],h=c.subarray(1,o+1),u=c.subarray(o+1);if(l!==0)throw new Error("Decryption failed");const w=this.mgf1(s.algorithm.hash,u,h.length);for(let N=0;N<h.length;N++)h[N]^=w[N];const B=this.mgf1(s.algorithm.hash,h,u.length);for(let N=0;N<u.length;N++)u[N]^=B[N];const C=m.createHash(s.algorithm.hash.name.replace("-","")).update(p.toUint8Array(e.label||new Uint8Array(0))).digest();for(let N=0;N<o;N++)if(C[N]!==u[N])throw new Error("Decryption failed");let P=o;for(;P<u.length;P++){const N=u[P];if(N===1)break;if(N!==0)throw new Error("Decryption failed")}if(P===u.length)throw new Error("Decryption failed");return c=u.subarray(P+1),new Uint8Array(c).buffer}async onExportKey(e,t){return V.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await V.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof Ue||r instanceof Ie))throw new TypeError("key: Is not RSA CryptoKey")}mgf1(e,t,r=0){const s=J.size(e)>>3,n=new Uint8Array(r),o=new Uint8Array(4),a=Math.ceil(r/s);for(let c=0;c<a;c++){o[0]=c>>>24,o[1]=c>>>16&255,o[2]=c>>>8&255,o[3]=c&255;const l=n.subarray(c*s);let h=m.createHash(e.name.replace("-","")).update(t).update(o).digest();h.length>l.length&&(h=h.subarray(0,l.length)),l.set(h)}return n}}class Ei extends L{constructor(){super(...arguments),this.name="RSAES-PKCS1-v1_5",this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]}}async onGenerateKey(e,t,r){const s=await V.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}checkGenerateKeyParams(e){if(this.checkRequiredProperty(e,"publicExponent"),!(e.publicExponent&&e.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const t=v.ToBase64(e.publicExponent);if(!(t==="Aw=="||t==="AQAB"))throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(e,"modulusLength"),e.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}async onEncrypt(e,t,r){const n=(void 0)(this.toCryptoOptions(t),new Uint8Array(r));return new Uint8Array(n).buffer}async onDecrypt(e,t,r){const n=(void 0)(this.toCryptoOptions(t),new Uint8Array(r));return new Uint8Array(n).buffer}async onExportKey(e,t){return V.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await V.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof Ue||r instanceof Ie))throw new TypeError("key: Is not RSA CryptoKey")}toCryptoOptions(e){const t=e.type.toUpperCase();return{key:`-----BEGIN ${t} KEY-----
${f(e).data.toString("base64")}
-----END ${t} KEY-----`,padding:void 0}}}const xi={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10",brainpoolP160r1:"1.3.36.3.3.2.8.1.1.1","1.3.36.3.3.2.8.1.1.1":"brainpoolP160r1",brainpoolP160t1:"1.3.36.3.3.2.8.1.1.2","1.3.36.3.3.2.8.1.1.2":"brainpoolP160t1",brainpoolP192r1:"1.3.36.3.3.2.8.1.1.3","1.3.36.3.3.2.8.1.1.3":"brainpoolP192r1",brainpoolP192t1:"1.3.36.3.3.2.8.1.1.4","1.3.36.3.3.2.8.1.1.4":"brainpoolP192t1",brainpoolP224r1:"1.3.36.3.3.2.8.1.1.5","1.3.36.3.3.2.8.1.1.5":"brainpoolP224r1",brainpoolP224t1:"1.3.36.3.3.2.8.1.1.6","1.3.36.3.3.2.8.1.1.6":"brainpoolP224t1",brainpoolP256r1:"1.3.36.3.3.2.8.1.1.7","1.3.36.3.3.2.8.1.1.7":"brainpoolP256r1",brainpoolP256t1:"1.3.36.3.3.2.8.1.1.8","1.3.36.3.3.2.8.1.1.8":"brainpoolP256t1",brainpoolP320r1:"1.3.36.3.3.2.8.1.1.9","1.3.36.3.3.2.8.1.1.9":"brainpoolP320r1",brainpoolP320t1:"1.3.36.3.3.2.8.1.1.10","1.3.36.3.3.2.8.1.1.10":"brainpoolP320t1",brainpoolP384r1:"1.3.36.3.3.2.8.1.1.11","1.3.36.3.3.2.8.1.1.11":"brainpoolP384r1",brainpoolP384t1:"1.3.36.3.3.2.8.1.1.12","1.3.36.3.3.2.8.1.1.12":"brainpoolP384t1",brainpoolP512r1:"1.3.36.3.3.2.8.1.1.13","1.3.36.3.3.2.8.1.1.13":"brainpoolP512r1",brainpoolP512t1:"1.3.36.3.3.2.8.1.1.14","1.3.36.3.3.2.8.1.1.14":"brainpoolP512t1"};function Te(i){const e=xi[i];if(!e)throw new A(`Cannot convert WebCrypto named curve '${i}' to OID`);return e}class rt extends Re{constructor(){super(...arguments),this.type="private"}getKey(){const e=x.parse(this.data,d.PrivateKeyInfo);return x.parse(e.privateKey,d.EcPrivateKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,te.toJSON(e))}fromJSON(e){if(!e.crv)throw new A("Cannot get named curve from JWK. Property 'crv' is required");const t=new d.PrivateKeyInfo;t.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",t.privateKeyAlgorithm.parameters=K.serialize(new d.ObjectIdentifier(Te(e.crv)));const r=D.fromJSON(e,{targetSchema:d.EcPrivateKey});return t.privateKey=K.serialize(r),this.data=Buffer.from(K.serialize(t)),this}}class st extends Re{constructor(){super(...arguments),this.type="public"}getKey(){const e=x.parse(this.data,d.PublicKeyInfo);return new d.EcPublicKey(e.publicKey)}toJSON(){const e=this.getKey(),t={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,te.toJSON(e))}fromJSON(e){if(!e.crv)throw new A("Cannot get named curve from JWK. Property 'crv' is required");const t=D.fromJSON(e,{targetSchema:d.EcPublicKey}),r=new d.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1",r.publicKeyAlgorithm.parameters=K.serialize(new d.ObjectIdentifier(Te(e.crv))),r.publicKey=K.toASN(t).valueHex,this.data=Buffer.from(K.serialize(r)),this}}class Ki extends L{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Ci extends L{constructor(){super(...arguments),this.name="SHA-256",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Ni extends L{constructor(){super(...arguments),this.name="SHA-384",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Ui extends L{constructor(){super(...arguments),this.name="SHA-512",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Ii extends L{constructor(){super(...arguments),this.name="SHA3-256",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Pi extends L{constructor(){super(...arguments),this.name="SHA3-384",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Vi extends L{constructor(){super(...arguments),this.name="SHA3-512",this.usages=[]}async onDigest(e,t){return J.digest(e,t)}}class Z{static async generateKey(e,t,r){const s=new rt;s.algorithm=e,s.extractable=t,s.usages=r.filter(c=>this.privateKeyUsages.indexOf(c)!==-1);const n=new st;n.algorithm=e,n.extractable=!0,n.usages=r.filter(c=>this.publicKeyUsages.indexOf(c)!==-1);const o=m.generateKeyPairSync("ec",{namedCurve:this.getOpenSSLNamedCurve(e.namedCurve),publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});return s.data=o.privateKey,n.data=o.publicKey,{privateKey:s,publicKey:n}}static async sign(e,t,r){const s=J.getAlgorithmName(e.hash),n=m.createSign(s);n.update(Buffer.from(r)),t.pem||(t.pem=`-----BEGIN PRIVATE KEY-----
${t.data.toString("base64")}
-----END PRIVATE KEY-----`);const o={key:t.pem},a=n.sign(o),c=x.parse(a,d.EcDsaSignature);return Ze.encodeSignature(c,U.get(t.algorithm.namedCurve).size).buffer}static async verify(e,t,r,s){const n=J.getAlgorithmName(e.hash),o=m.createVerify(n);o.update(Buffer.from(s)),t.pem||(t.pem=`-----BEGIN PUBLIC KEY-----
${t.data.toString("base64")}
-----END PUBLIC KEY-----`);const a={key:t.pem},c=new d.EcDsaSignature,l=U.get(t.algorithm.namedCurve),h=Ze.decodeSignature(r,l.size);c.r=p.toArrayBuffer(h.r),c.s=p.toArrayBuffer(h.s);const u=Buffer.from(K.serialize(c));return o.verify(a,u)}static async deriveBits(e,t,r){const s=this.getOpenSSLNamedCurve(t.algorithm.namedCurve),n=m.createECDH(s),o=x.parse(t.data,d.PrivateKeyInfo),a=x.parse(o.privateKey,d.EcPrivateKey);n.setPrivateKey(Buffer.from(a.privateKey));const c=x.parse(e.public.data,d.PublicKeyInfo),l=n.computeSecret(Buffer.from(c.publicKey));return r===null?l:new Uint8Array(l).buffer.slice(0,r>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return te.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return x.parse(t.data,d.PublicKeyInfo).publicKey;default:throw new A("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,s,n){switch(e.toLowerCase()){case"jwk":if(t.d){const a=D.fromJSON(t,{targetSchema:d.EcPrivateKey});return this.importPrivateKey(a,r,s,n)}else{const a=D.fromJSON(t,{targetSchema:d.EcPublicKey});return this.importPublicKey(a,r,s,n)}case"raw":{const o=new d.EcPublicKey(t);return this.importPublicKey(o,r,s,n)}case"spki":{const o=x.parse(new Uint8Array(t),d.PublicKeyInfo),a=new d.EcPublicKey(o.publicKey);return this.assertKeyParameters(o.publicKeyAlgorithm.parameters,r.namedCurve),this.importPublicKey(a,r,s,n)}case"pkcs8":{const o=x.parse(new Uint8Array(t),d.PrivateKeyInfo),a=x.parse(o.privateKey,d.EcPrivateKey);return this.assertKeyParameters(o.privateKeyAlgorithm.parameters,r.namedCurve),this.importPrivateKey(a,r,s,n)}default:throw new A("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static assertKeyParameters(e,t){if(!e)throw new oe("Key info doesn't have required parameters");let r="";try{r=x.parse(e,d.ObjectIdentifier).value}catch{throw new oe("Cannot read key info parameters")}if(Te(t)!==r)throw new oe("Key info parameter doesn't match to named curve")}static async importPrivateKey(e,t,r,s){const n=new d.PrivateKeyInfo;n.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1",n.privateKeyAlgorithm.parameters=K.serialize(new d.ObjectIdentifier(Te(t.namedCurve))),n.privateKey=K.serialize(e);const o=new rt;return o.data=Buffer.from(K.serialize(n)),o.algorithm=Object.assign({},t),o.extractable=r,o.usages=s,o}static async importPublicKey(e,t,r,s){const n=new d.PublicKeyInfo;n.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1";const o=Te(t.namedCurve);n.publicKeyAlgorithm.parameters=K.serialize(new d.ObjectIdentifier(o)),n.publicKey=e.value;const a=new st;return a.data=Buffer.from(K.serialize(n)),a.algorithm=Object.assign({},t),a.extractable=r,a.usages=s,a}static getOpenSSLNamedCurve(e){switch(e.toUpperCase()){case"P-256":return"prime256v1";case"K-256":return"secp256k1";case"P-384":return"secp384r1";case"P-521":return"secp521r1";default:return e}}}Z.publicKeyUsages=["verify"];Z.privateKeyUsages=["sign","deriveKey","deriveBits"];class Hi extends Wn{constructor(){super(...arguments),this.namedCurves=U.names,this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512","shake128","shake256","SHA3-256","SHA3-384","SHA3-512"]}async onGenerateKey(e,t,r){const s=await Z.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onSign(e,t,r){return Z.sign(e,f(t),new Uint8Array(r))}async onVerify(e,t,r,s){return Z.verify(e,f(t),new Uint8Array(r),new Uint8Array(s))}async onExportKey(e,t){return Z.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await Z.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof rt||r instanceof st))throw new TypeError("key: Is not EC CryptoKey")}}class Oi extends ms{constructor(){super(...arguments),this.namedCurves=U.names}async onGenerateKey(e,t,r){const s=await Z.generateKey({...e,name:this.name},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onExportKey(e,t){return Z.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await Z.importKey(e,t,{...r,name:this.name},s,n);return b(o)}checkCryptoKey(e,t){super.checkCryptoKey(e,t);const r=f(e);if(!(r instanceof rt||r instanceof st))throw new TypeError("key: Is not EC CryptoKey")}async onDeriveBits(e,t,r){return await Z.deriveBits({...e,public:f(e.public)},f(t),r)}}const Ri={[d.idEd448]:"Ed448",ed448:d.idEd448,[d.idX448]:"X448",x448:d.idX448,[d.idEd25519]:"Ed25519",ed25519:d.idEd25519,[d.idX25519]:"X25519",x25519:d.idX25519};function Ms(i){const e=Ri[i.toLowerCase()];if(!e)throw new A(`Cannot convert WebCrypto named curve '${i}' to OID`);return e}class ur extends Re{constructor(){super(...arguments),this.type="private"}getKey(){const e=x.parse(this.data,d.PrivateKeyInfo);return x.parse(e.privateKey,d.CurvePrivateKey)}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,te.toJSON(e))}fromJSON(e){if(!e.crv)throw new A("Cannot get named curve from JWK. Property 'crv' is required");const t=new d.PrivateKeyInfo;t.privateKeyAlgorithm.algorithm=Ms(e.crv);const r=D.fromJSON(e,{targetSchema:d.CurvePrivateKey});return t.privateKey=K.serialize(r),this.data=Buffer.from(K.serialize(t)),this}}class hr extends Re{constructor(){super(...arguments),this.type="public"}getKey(){return x.parse(this.data,d.PublicKeyInfo).publicKey}toJSON(){const e=this.getKey(),t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,{x:v.ToBase64Url(e)})}fromJSON(e){if(!e.crv)throw new A("Cannot get named curve from JWK. Property 'crv' is required");if(!e.x)throw new A("Cannot get property from JWK. Property 'x' is required");const t=new d.PublicKeyInfo;return t.publicKeyAlgorithm.algorithm=Ms(e.crv),t.publicKey=v.FromBase64Url(e.x),this.data=Buffer.from(K.serialize(t)),this}}class Q{static async generateKey(e,t,r){const s=new ur;s.algorithm=e,s.extractable=t,s.usages=r.filter(l=>this.privateKeyUsages.indexOf(l)!==-1);const n=new hr;n.algorithm=e,n.extractable=!0,n.usages=r.filter(l=>this.publicKeyUsages.indexOf(l)!==-1);const o=e.namedCurve.toLowerCase(),a=m.generateKeyPairSync(o,{publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});return s.data=a.privateKey,n.data=a.publicKey,{privateKey:s,publicKey:n}}static async sign(e,t,r){t.pem||(t.pem=`-----BEGIN PRIVATE KEY-----
${t.data.toString("base64")}
-----END PRIVATE KEY-----`);const s={key:t.pem},n=m.sign(null,Buffer.from(r),s);return p.toArrayBuffer(n)}static async verify(e,t,r,s){t.pem||(t.pem=`-----BEGIN PUBLIC KEY-----
${t.data.toString("base64")}
-----END PUBLIC KEY-----`);const n={key:t.pem};return m.verify(null,Buffer.from(s),n,Buffer.from(r))}static async deriveBits(e,t,r){const s=m.createPublicKey({key:e.public.data,format:"der",type:"spki"}),n=m.createPrivateKey({key:t.data,format:"der",type:"pkcs8"}),o=m.diffieHellman({publicKey:s,privateKey:n});return new Uint8Array(o).buffer.slice(0,r>>3)}static async exportKey(e,t){switch(e.toLowerCase()){case"jwk":return te.toJSON(t);case"pkcs8":case"spki":return new Uint8Array(t.data).buffer;case"raw":return x.parse(t.data,d.PublicKeyInfo).publicKey;default:throw new A("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(e,t,r,s,n){switch(e.toLowerCase()){case"jwk":{const o=t;if(o.d){const a=D.fromJSON(t,{targetSchema:d.CurvePrivateKey});return this.importPrivateKey(a,r,s,n)}else{if(!o.x)throw new TypeError("keyData: Cannot get required 'x' filed");return this.importPublicKey(v.FromBase64Url(o.x),r,s,n)}}case"raw":return this.importPublicKey(t,r,s,n);case"spki":{const o=x.parse(new Uint8Array(t),d.PublicKeyInfo);return this.importPublicKey(o.publicKey,r,s,n)}case"pkcs8":{const o=x.parse(new Uint8Array(t),d.PrivateKeyInfo),a=x.parse(o.privateKey,d.CurvePrivateKey);return this.importPrivateKey(a,r,s,n)}default:throw new A("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static importPrivateKey(e,t,r,s){const n=new ur;return n.fromJSON({crv:t.namedCurve,d:v.ToBase64Url(e.d)}),n.algorithm=Object.assign({},t),n.extractable=r,n.usages=s,n}static async importPublicKey(e,t,r,s){const n=new hr;return n.fromJSON({crv:t.namedCurve,x:v.ToBase64Url(e)}),n.algorithm=Object.assign({},t),n.extractable=r,n.usages=s,n}}Q.publicKeyUsages=["verify"];Q.privateKeyUsages=["sign","deriveKey","deriveBits"];class Li extends Zn{async onGenerateKey(e,t,r){const s=await Q.generateKey({name:this.name,namedCurve:e.namedCurve.replace(/^ed/i,"Ed")},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onSign(e,t,r){return Q.sign(e,f(t),new Uint8Array(r))}async onVerify(e,t,r,s){return Q.verify(e,f(t),new Uint8Array(r),new Uint8Array(s))}async onExportKey(e,t){return Q.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await Q.importKey(e,t,{...r,name:this.name},s,n);return b(o)}}class Di extends Xn{async onGenerateKey(e,t,r){const s=await Q.generateKey({name:this.name,namedCurve:e.namedCurve.toUpperCase()},t,r);return{privateKey:b(s.privateKey),publicKey:b(s.publicKey)}}async onDeriveBits(e,t,r){return await Q.deriveBits({...e,public:f(e.public)},f(t),r)}async onExportKey(e,t){return Q.exportKey(e,f(t))}async onImportKey(e,t,r,s,n){const o=await Q.importKey(e,t,{...r,name:this.name},s,n);return b(o)}}class fr extends pe{}class Ti extends ii{async onDeriveBits(e,t,r){return new Promise((s,n)=>{const o=p.toArrayBuffer(e.salt),a=e.hash.name.replace("-","");m.pbkdf2(f(t).data,Buffer.from(o),e.iterations,r>>3,a,(c,l)=>{c?n(c):s(new Uint8Array(l).buffer)})})}async onImportKey(e,t,r,s,n){if(e==="raw"){const o=new fr;return o.data=Buffer.from(t),o.algorithm={name:this.name},o.extractable=!1,o.usages=n,b(o)}throw new A("format: Must be 'raw'")}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof fr))throw new TypeError("key: Is not PBKDF CryptoKey")}}class De extends pe{get alg(){return`HS${this.algorithm.hash.name.toUpperCase().replace("SHA-","")}`}set alg(e){}}k([H({name:"k",converter:Qt})],De.prototype,"data",void 0);class $i extends ni{async onGenerateKey(e,t,r){const s=(e.length||this.getDefaultLength(e.hash.name))>>3<<3,n=new De;return n.algorithm={...e,length:s,name:this.name},n.extractable=t,n.usages=r,n.data=m.randomBytes(s>>3),b(n)}async onSign(e,t,r){const s=J.getAlgorithmName(t.algorithm.hash),n=m.createHmac(s,f(t).data).update(Buffer.from(r)).digest();return new Uint8Array(n).buffer}async onVerify(e,t,r,s){const n=J.getAlgorithmName(t.algorithm.hash);return m.createHmac(n,f(t).data).update(Buffer.from(s)).digest().compare(Buffer.from(r))===0}async onImportKey(e,t,r,s,n){let o;switch(e.toLowerCase()){case"jwk":o=D.fromJSON(t,{targetSchema:De});break;case"raw":o=new De,o.data=Buffer.from(t);break;default:throw new A("format: Must be 'jwk' or 'raw'")}return o.algorithm={hash:{name:r.hash.name},name:this.name,length:o.data.length<<3},o.extractable=s,o.usages=n,b(o)}async onExportKey(e,t){switch(e.toLowerCase()){case"jwk":return te.toJSON(f(t));case"raw":return new Uint8Array(f(t).data).buffer;default:throw new A("format: Must be 'jwk' or 'raw'")}}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof De))throw new TypeError("key: Is not HMAC CryptoKey")}}class yr extends pe{}class Mi extends oi{async onImportKey(e,t,r,s,n){if(e.toLowerCase()!=="raw")throw new A("Operation not supported");const o=new yr;return o.data=Buffer.from(t),o.algorithm={name:this.name},o.extractable=s,o.usages=n,b(o)}async onDeriveBits(e,t,r){const s=e.hash.name.replace("-",""),n=m.createHash(s).digest().length,o=r/8,a=p.toUint8Array(e.info),c=m.createHmac(s,p.toUint8Array(e.salt)).update(p.toUint8Array(f(t).data)).digest(),l=[Buffer.alloc(0)],h=Math.ceil(o/n)+1;for(let u=1;u<h;++u)l.push(m.createHmac(s,c).update(Buffer.concat([l[u-1],a,Buffer.from([u])])).digest());return Buffer.concat(l).slice(0,o)}checkCryptoKey(e,t){if(super.checkCryptoKey(e,t),!(f(e)instanceof yr))throw new TypeError("key: Is not HKDF CryptoKey")}}class _s{static digest(e,t){const r=m.createHash(e.name.toLowerCase(),{outputLength:e.length}).update(Buffer.from(t)).digest();return new Uint8Array(r).buffer}}class _i extends ai{async onDigest(e,t){return _s.digest(e,t)}}class Ji extends ci{async onDigest(e,t){return _s.digest(e,t)}}class Fi extends Zt{constructor(){var e;super(),this.providers.set(new hi),this.providers.set(new gi),this.providers.set(new mi),this.providers.set(new pi),this.providers.set(new wi),this.providers.set(new vi),this.providers.set(new Ai),this.providers.set(new bi),this.providers.set(new ki),this.providers.set(new Bi),this.providers.set(new Si),this.providers.set(new Ei),this.providers.set(new Hi),this.providers.set(new Oi),this.providers.set(new Ki),this.providers.set(new Ci),this.providers.set(new Ni),this.providers.set(new Ui),this.providers.set(new Ti),this.providers.set(new $i),this.providers.set(new Mi);const t=(e=/^v(\d+)/.exec(void 0))===null||e===void 0?void 0:e[1];t&&parseInt(t,10)>=12&&(this.providers.set(new _i),this.providers.set(new Ji));const r=(void 0)();r.includes("sha3-256")&&this.providers.set(new Ii),r.includes("sha3-384")&&this.providers.set(new Pi),r.includes("sha3-512")&&this.providers.set(new Vi),t&&parseInt(t,10)>=14&&(this.providers.set(new Li),this.providers.set(new Di))}}class Zi extends li{constructor(){super(...arguments),this.subtle=new Fi}getRandomValues(e){if(!ArrayBuffer.isView(e))throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");const t=Buffer.from(e.buffer,e.byteOffset,e.byteLength);return m.randomFillSync(t),e}}export{Zi as Crypto,Et as CryptoKey};
//# sourceMappingURL=webcrypto.es.js.map
